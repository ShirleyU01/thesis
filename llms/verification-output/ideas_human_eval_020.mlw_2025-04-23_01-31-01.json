{
    "ideas": [
        {
            "description": "Add precise contracts (pre- and postconditions), variants for recursion, and strengthen invariants and ghost code to enable automatic SMT verification of correctness and postconditions. We add preconditions to ensure input lists have at least two elements, specify contracts for helpers, and provide variants to all recursive functions for termination proofs.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.NthNoOpt\n\n  (* Helper to check that the two elements a and b really exist in the input list *)\n  predicate elements_in_list (a: int) (b: int) (l: list int) =\n    mem a l /\\ mem b l\n\n  (* Loop invariant for find_closest_helper:  \n     - best is the smallest difference found so far\n     - (a, b) are two numbers from the original list with that difference *)\n  let rec find_closest_helper (l: list int) (current: int) (best: int) (a: int) (b: int) : (int, int, int)\n    requires { length l >= 0 }\n    requires { mem current (Cons current l) }\n    requires { best >= 0 }\n    requires { elements_in_list a b (Cons current l) }\n    variant  { length l }\n    ensures  { let (r_best, r_a, r_b) = result in\n                r_best >= 0 /\\\n                elements_in_list r_a r_b (Cons current l) /\\\n                (forall i j. mem i (Cons current l) /\\ mem j (Cons current l) -> abs (i-j) >= r_best)\n              }\n    =\n    match l with\n    | Nil -> (best, a, b)\n    | Cons x xs ->\n      let d = abs (x - current) in\n      if d < best then find_closest_helper xs current d (min x current) (max x current)\n      else find_closest_helper xs current best a b\n    end\n\n  (*\n    Invariant: at each step, (a,b) are from the suffix list, best is their distance, and best is minimal for all examined pairs so far\n   *)\n  let rec aux (l: list int) (best: int) (a: int) (b: int) : (int, int)\n    requires { length l >= 2 }\n    requires { best >= 0 }\n    requires { elements_in_list a b l }\n    variant  { length l }\n    ensures  { let (out_a, out_b) = result in\n                elements_in_list out_a out_b l /\\\n                (forall i j. mem i l /\\ mem j l -> abs (i-j) >= abs (out_a - out_b))\n              }\n    =\n    match l with\n    | Nil -> (a, b)\n    | Cons x xs ->\n      let (new_best, new_a, new_b) = find_closest_helper xs x best a b in\n      aux xs new_best new_a new_b\n    end\n\n  (*\n    Precondition: list has at least two elements. \n    Postcondition: result is a list of length 2 containing the closest pair (in sorted order).\n   *)\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    ensures { length result = 2 }\n    ensures { forall x y. (mem x numbers /\\ mem y numbers) -> abs (x-y) >= abs (nth 0 result - nth 1 result) }\n    ensures { nth 0 result <= nth 1 result }\n    ensures { mem (nth 0 result) numbers /\\ mem (nth 1 result) numbers }\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let first_diff = abs (x - y) in\n      let (a, b) = aux numbers first_diff (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend\n"
        }
    ]
}