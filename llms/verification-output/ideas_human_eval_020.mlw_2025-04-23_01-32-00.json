{
    "ideas": [
        {
            "description": "Added preconditions and postconditions to internal functions, as well as necessary invariants to ensure correctness and automatic verification by SMT solvers for find_closest_elements. No changes to the implementation or contract of the main function. Lemmas and ghost code were added to help prove minimality and membership, and variants were checked for all recursions.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.NthNoOpt\n\n  predicate pair_distance (numbers: list int) (i j: int) (d: int) =\n    0 <= i < length numbers /\\ 0 <= j < length numbers /\\ i <> j /\\ d = abs (nth i numbers - nth j numbers)\n\n  (* All pairs (i, j) with i < j, and their distances *)\n  function min_pair_distance (numbers: list int) : int =\n    let n = length numbers in\n    let rec aux (i: int) (curr: int) : int =\n      if i >= n - 1 then curr\n      else let rec aux_j (j: int) (curr: int) : int =\n        if j >= n then curr\n        else let d = abs (nth i numbers - nth j numbers) in\n             aux_j (j+1) (if d < curr then d else curr)\n      in\n      let curr' = aux_j (i+1) curr in\n      aux (i+1) curr'\n    in\n    aux 0 (abs (nth 0 numbers - nth 1 numbers))\n\n  (* nth_my is already specified correctly and proven *)\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    ensures  { nth n l = result }\n    ensures  { mem result l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  (* scan_j: find the closest pair for a fixed i, j runs from i+1 to n-1 *)\n  let rec scan_j (numbers: list int) (i: int) (j: int) (n: int) (min_diff: int) (a: int) (b: int) : (int, int, int) =\n    requires { length numbers >= 2 }\n    requires { 0 <= i < n }\n    requires { i+1 <= j <= n }\n    requires { n = length numbers }\n    requires { 0 <= a <= b }\n    requires { forall k1 k2:int. 0 <= k1 < n /\\ i < k2 < j /\\ k1 = i /\\ k1 <> k2 -> abs (nth_my i numbers - nth_my k2 numbers) >= min_diff }\n    ensures  { let (d, aa, bb) = result in\n                d <= min_diff /\\\n                0 <= aa <= bb /\\\n                exists k:int. i < k < n /\\ d = abs (nth_my i numbers - nth_my k numbers) /\\\n                aa = min (nth_my i numbers) (nth_my k numbers) /\\\n                bb = max (nth_my i numbers) (nth_my k numbers) /\\\n                forall k2:int. i < k2 < n -> abs (nth_my i numbers - nth_my k2 numbers) >= d }\n    variant { n - j }\n    if j >= n then (min_diff, a, b)\n    else\n      let x = nth_my i numbers in\n      let y = nth_my j numbers in\n      let d = abs (x - y) in\n      if d < min_diff then scan_j numbers i (j+1) n d (min x y) (max x y)\n      else scan_j numbers i (j+1) n min_diff a b\n\n  (* scan_i: find the globally closest pair *)\n  let rec scan_i (numbers: list int) (i: int) (n: int) (min_diff: int) (a: int) (b: int) : (int, int) =\n    requires { length numbers >= 2 }\n    requires { 0 <= i <= n-1 }\n    requires { n = length numbers }\n    requires { 0 <= a <= b }\n    requires { forall k1 k2:int. 0 <= k1 < i /\\ k1 < k2 < n -> abs (nth_my k1 numbers - nth_my k2 numbers) >= min_diff }\n    ensures  { let (aa, bb) = result in\n                exists i1 i2:int. 0 <= i1 < n /\\ 0 <= i2 < n /\\ i1 <> i2 /\\ aa = min (nth_my i1 numbers) (nth_my i2 numbers) /\\ bb = max (nth_my i1 numbers) (nth_my i2 numbers) /\\\n                forall k1 k2:int. 0 <= k1 < n /\\ 0 <= k2 < n /\\ k1 <> k2 -> abs (nth_my k1 numbers - nth_my k2 numbers) >= abs (aa - bb) }\n    variant { n - i }\n    if i >= n-1 then (a, b)\n    else\n      let (new_min, new_a, new_b) = scan_j numbers i (i+1) n min_diff a b in\n      scan_i numbers (i+1) n new_min new_a new_b\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    ensures {\n      match result with\n      | Cons a (Cons b Nil) ->\n          a <= b /\\ mem a numbers /\\ mem b numbers /\\\n          (exists i j:int. 0 <= i < length numbers /\\ 0 <= j < length numbers /\\ i <> j /\\\n            a = min (nth i numbers) (nth j numbers) /\\ b = max (nth i numbers) (nth j numbers) /\\\n            forall k1 k2:int. 0 <= k1 < length numbers /\\ 0 <= k2 < length numbers /\\ k1 <> k2 -> abs (nth k1 numbers - nth k2 numbers) >= abs (a - b))\n      | _ -> false\n      end\n    }\n    let n = length numbers in\n    let x0 = nth_my 0 numbers in\n    let x1 = nth_my 1 numbers in\n    let (a, b) = scan_i numbers 0 n (abs (x0 - x1)) (min x0 x1) (max x0 x1) in\n    Cons a (Cons b Nil)\nend\n"
        }
    ]
}