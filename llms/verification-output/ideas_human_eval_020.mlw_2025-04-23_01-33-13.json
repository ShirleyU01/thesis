{
    "ideas": [
        {
            "description": "Add sufficient pre- and postconditions (contracts) to all functions, including the recursive helpers. Add loop invariants (as needed for auxiliary recursions expressed as loops). Add ghost code for clarity of correctness, and add minimal lemmas to justify the properties of min_pair and all_pairs. This ensures that find_closest_elements returns two numbers from the original list in sorted order, and that they are the closest pair. No change to the body of the code.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Append\n  use list.Mem\n  use list.Permut\n\n  (* nth_my: safe version of nth *)\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    ensures  { nth n l = result }\n    ensures  { mem result l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  (* all_pairs: produces all pairs (d, x, y) with i < j < n *)\n  let rec all_pairs (numbers: list int) (i: int) (n: int) : list (int, int, int) =\n    requires { 0 <= i /\\ i < n /\\ n = length numbers }\n    ensures  { forall e. mem e result ->\n      let (d, x, y) = e in\n      exists j. i < j /\\ j < n /\\ x = nth_my i numbers /\\ y = nth_my j numbers /\\ d = abs (x - y) }\n    ensures  { forall k l. (i < k /\\ k < n /\\ i < l /\\ l < n) ->\n      mem (abs (nth_my i numbers - nth_my l numbers), nth_my i numbers, nth_my l numbers) result }\n    variant { n - i }\n    if i >= n-1 then Nil\n    else\n      let rec aux (j: int) : list (int, int, int) =\n        requires { i+1 <= j /\\ j <= n }\n        ensures  { forall e. mem e result ->\n          let (d, x, y) = e in\n          exists k. j <= k < n /\\ x = nth_my i numbers /\\ y = nth_my k numbers /\\ d = abs (x - y) }\n        ensures  { length result = n - j }\n        variant { n - j }\n        if j >= n then Nil\n        else\n          let x = nth_my i numbers in\n          let y = nth_my j numbers in\n          let d = abs (x - y) in\n          Cons (d, x, y) (aux (j+1))\n      in\n      aux (i+1) ++ all_pairs numbers (i+1) n\n\n  (* min_pair: returns (a, b) where min_d is the minimum d seen so far *)\n  let rec min_pair (l: list (int, int, int)) (min_d:int) (a:int) (b:int) : (int, int) =\n    requires { forall e. mem e l -> let (d, x, y) = e in d >= 0 }\n    ensures  { let (ra, rb) = result in\n      (* min_d is the minimum d in l or initial min_d *)\n      let m = fold_left (fun acc e -> let (d, x, y) = e in if d < acc then d else acc) min_d l in\n      exists e. (mem e l \\/ (l = Nil /\\ min_d = abs (a - b))) /\\ let (d, x, y) = e in d = m /\\ ra = min x y /\\ rb = max x y }\n    variant { length l }\n    match l with\n    | Nil -> (a, b)\n    | Cons (d, x, y) xs ->\n      if d < min_d then min_pair xs d (min x y) (max x y)\n      else min_pair xs min_d a b\n    end\n\n  (* Main function *)\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    ensures  { length result = 2 }\n    ensures  { let a = nth 0 result in let b = nth 1 result in a <= b }\n    ensures  { mem (nth 0 result) numbers /\\ mem (nth 1 result) numbers }\n    ensures  { let a = nth 0 result in let b = nth 1 result in\n      forall i. 0 <= i < length numbers ->\n      forall j. 0 <= j < length numbers -> i <> j -> abs (a - b) <= abs (nth i numbers - nth j numbers) }\n    let n = length numbers in\n    let x0 = nth_my 0 numbers in\n    let x1 = nth_my 1 numbers in\n    let pairs = all_pairs numbers 0 n in\n    let (a, b) = min_pair pairs (abs (x0 - x1)) (min x0 x1) (max x0 x1) in\n    Cons a (Cons b Nil)\nend\n"
        }
    ]
}