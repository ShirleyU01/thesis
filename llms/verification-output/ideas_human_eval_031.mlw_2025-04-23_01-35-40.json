{
    "ideas": [
        {
            "description": "The code is verified by adding a loop variant for termination and a loop invariant that maintains the primality characterization in the while loop. The invariant expresses that no divisors of n have been found in the range (d+1)..(n-1), and that found is true if and only if a divisor has been found in the current search range. This, together with the loop variant and the existing contract, is sufficient for automatic verification by SMT solvers.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n\n  let is_prime (n: int) : bool =\n    ensures { result <-> (n >= 2 /\\ forall d: int. 2 <= d /\\ d < n -> not (mod n d = 0)) }\n    let ref found = false in\n    let ref d = n - 1 in\n    while d >= 2 && not found do\n      invariant { 1 <= d + 1 <= n /\\\n        (* found is true iff there exists k in [d+1, n-1] such that mod n k = 0 *)\n        (found <-> (exists k: int. d + 1 <= k < n /\\ mod n k = 0)) /\\\n        (* for all k in [d+1, n-1], if mod n k = 0, then found *)\n        (forall k: int. d + 1 <= k < n -> (mod n k = 0 -> found))\n      }\n      variant { d }\n      if mod n d = 0 then found <- true;\n      d <- d - 1\n    done;\n    not found\nend\n"
        }
    ]
}