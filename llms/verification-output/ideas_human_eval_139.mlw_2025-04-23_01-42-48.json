{
    "ideas": [
        {
            "description": "Add sufficient contracts (pre- and post-conditions) and variants to helper functions to make the code verifiable by SMT solvers for the special_factorial contract. Prove the link between the spec_fact predicate and the implementation by specifying the behavior of build_list, product, and map_fact, and provide a lemma about the product of mapped factorials. No implementation changes are made, only specification and verification annotations.",
            "implementation": "module HumanEval139\n  use int.Int\n  use int.Fact\n  use list.List\n  use list.Length\n\n  predicate spec_fact (n : int) (a : int)\n    axiom spec_fact_base :\n      forall a. spec_fact 1 a <-> a = 1\n    axiom spec_fact_ind :\n      forall a n . spec_fact n a <-> exists b. spec_fact (n-1) b /\\ a = b * fact n\n\n  (* build_list creates the list [a, a+1, ..., b] when a <= b; [] otherwise *)\n  let rec build_list (a: int) (b: int) : list int\n    requires { a >= 1 }\n    requires { b >= 0 }\n    variant { if a > b then 0 else b - a + 1 }\n    ensures { result = Nil <-> a > b }\n    ensures { a > b -> result = Nil }\n    ensures { a <= b -> length result = b - a + 1 }\n    ensures { forall i:int. 0 <= i < length result -> nth result i = a + i }\n  = if a > b then Nil else Cons a (build_list (a+1) b)\n\n  (* product computes the product of list elements; product Nil = 1 *)\n  let rec product (l: list int) : int\n    variant { length l }\n    ensures { (l = Nil -> result = 1) }\n    ensures { (exists x xs. l = Cons x xs) -> result = nth l 0 * product (tl l) }\n  = match l with | Nil -> 1 | Cons x xs -> x * product xs end\n\n  (* map_fact applies fact to each element of the list *)\n  let rec map_fact (l: list int) : list int\n    variant { length l }\n    ensures { length result = length l }\n    ensures { forall i:int. 0 <= i < length l -> nth result i = fact (nth l i) }\n  = match l with | Nil -> Nil | Cons x xs -> Cons (fact x) (map_fact xs) end\n\n  (* Lemma: product (map_fact (build_list 1 n)) computes n! * (n-1)! * ... * 1! for n >= 1 *)\n  lemma product_of_map_fact_build_list :\n    forall n:int. n >= 1 ->\n    product (map_fact (build_list 1 n)) =\n      if n = 1 then 1 else product (map_fact (build_list 1 (n-1))) * fact n\n\n  (* Lemma: product (map_fact (build_list 1 n)) realizes spec_fact *)\n  lemma product_map_fact_spec_fact :\n    forall n:int. n >= 1 -> spec_fact n (product (map_fact (build_list 1 n)))\n\n  let special_factorial (n: int) : int\n    requires { n >= 1 }\n    ensures { spec_fact n result }\n  = let l = build_list 1 n in\n    product (map_fact l)\nend\n"
        }
    ]
}