{
    "ideas": [
        {
            "description": "Add loop invariants to the while loop in rolling_max to prove the postconditions. The invariants maintain that the res list has length i, and for each k < i, the res[k] is the maximum of l[0..k]. This directly supports the postconditions about the result. No change to the implementation, only to the specification.",
            "implementation": "module HumanEval009\n  use int.Int\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Append\n  use list.Mem\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    ensures  { nth n l = result }\n    ensures  { mem result l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  (* Helper function: maximum of prefix l[0..k] *)\n  function max_prefix (l: list int) (k: int) : int =\n    if k < 0 then 0 else\n      let rec go (i: int) (acc: int) : int =\n        variant { k - i }\n        if i > k then acc else go (i+1) (max acc (nth i l))\n      in go 0 (nth 0 l)\n\n  let rolling_max (l: list int) : list int =\n    ensures { forall i . 0 <= i < length l -> nth i result >= nth i l }\n    ensures { forall i . 0 <= i < length l -> exists j. 0 <= j <= i /\\ nth i result = nth j l }\n    let n = length l in\n    if n = 0 then Nil else\n    let ref res = Nil in\n    let ref i = 0 in\n    let ref cur = nth_my 0 l in\n    while i < n do\n      invariant { 0 <= i <= n }\n      invariant { length res = i }\n      invariant { forall k. 0 <= k < i -> nth k res >= nth k l }\n      invariant { forall k. 0 <= k < i -> exists j. 0 <= j <= k /\\ nth k res = nth j l }\n      variant { n - i }\n      let v = nth_my i l in\n      cur <- max cur v;\n      res <- res ++ (Cons cur Nil);\n      i <- i + 1\n    done;\n    res\nend\n"
        }
    ]
}