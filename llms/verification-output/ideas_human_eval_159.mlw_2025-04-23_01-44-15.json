{
    "ideas": [
        {
            "description": "The function eat is already correct and non-recursive, so no variants or invariants are needed. To aid automatic verification, we add a precondition reflecting the input constraints (0 <= number, need, remaining <= 1000) as in the problem description. This strengthens the context for the postcondition proof and ensures all arithmetic stays within bounds. No lemmas or ghost code are needed.",
            "implementation": "module HumanEval159\n  use int.Int\n  use int.MinMax\n  use list.List\n\n  let eat (number:int) (need:int) (remaining:int) : list int =\n  requires { 0 <= number <= 1000 }\n  requires { 0 <= need <= 1000 }\n  requires { 0 <= remaining <= 1000 }\n  ensures {\n        let total_eaten = if need <= remaining then number + need else number + remaining in\n        let carrots_left = if need <= remaining then remaining - need else 0 in\n        result = Cons total_eaten (Cons carrots_left Nil)\n        }\n    let to_eat = min need remaining in\n    let total = number + to_eat in\n    let left = remaining - to_eat in\n    Cons total (Cons left Nil)\nend\n"
        }
    ]
}