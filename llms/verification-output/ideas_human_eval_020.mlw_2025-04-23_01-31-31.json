{
    "ideas": [
        {
            "description": "Add full formal specification to the insertion sort and closest pair functions, including pre- and postconditions, and add variants for recursion. Prove that find_closest_elements returns a list of two elements which are the closest pair (in sorted order) from the input, if the input has at least two elements. Add necessary contracts, variants, and auxiliary lemmas. No changes to core implementation.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.NthNoOpt\n\n  predicate sorted (l: list int) =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x <= y /\\ sorted (Cons y ys)\n    end\n\n  predicate adjacent_closest_pair (l: list int) (a:int) (b:int) =\n    let rec aux (l: list int) (min_diff: int) (a:int) (b:int) : bool =\n      match l with\n      | Cons x (Cons y ys) ->\n          let d = abs (x - y) in\n          if d < min_diff then aux (Cons y ys) d x y\n          else aux (Cons y ys) min_diff a b\n      | _ -> true\n      end\n    in\n    match l with\n    | Cons x (Cons y xs) ->\n        let min_diff = abs (x - y) in\n        let rec check (l: list int) (cur_min: int) (a0:int) (b0:int) : bool =\n          match l with\n          | Cons x1 (Cons x2 xs1) ->\n              let d = abs (x1 - x2) in\n              if d < cur_min then check (Cons x2 xs1) d x1 x2\n              else check (Cons x2 xs1) cur_min a0 b0\n          | _ -> a0 = a /\\ b0 = b\n          end\n        in\n        check (Cons x (Cons y xs)) min_diff x y\n    | _ -> false\n    end\n\n  predicate exists_adjacent_pair_with_diff (l: list int) (d: int) =\n    match l with\n    | Cons x (Cons y xs) ->\n        abs (x - y) = d \\/ exists_adjacent_pair_with_diff (Cons y xs) d\n    | _ -> false\n    end\n\n  (* insert x into a sorted list l, result is sorted and a permutation *)\n  let rec insert (x:int) (l:list int) : list int\n    ensures { sorted l -> sorted result }\n    ensures { mem x result }\n    ensures { forall y. mem y l -> mem y result }\n    ensures { forall y. mem y result -> y = x \\/ mem y l }\n    variant { l }\n  = match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n    end\n\n  (* standard insertion sort: result is sorted, a permutation, and same length *)\n  let rec sort (l:list int) : list int\n    ensures { length result = length l }\n    ensures { sorted result }\n    ensures { forall x. mem x l <-> mem x result }\n    variant { l }\n  = match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (sort xs)\n    end\n\n  (* Find the adjacent pair with minimal diff, in a sorted list l *)\n  let rec closest_adjacent (l:list int) (min_diff: int) (a:int) (b:int) : (int, int)\n    requires { sorted l }\n    requires { length l >= 2 }\n    requires { exists_adjacent_pair_with_diff l min_diff }\n    ensures {\n      let (a0, b0) = result in\n      exists_adjacent_pair_with_diff l (abs (a0 - b0)) /\\\n      forall x y. (adjacent l x y -> abs (x-y) >= abs (a0-b0))\n    }\n    variant { length l }\n  = match l with\n    | Cons x (Cons y ys) ->\n      let d = abs (x - y) in\n      if d < min_diff then closest_adjacent (Cons y ys) d x y else closest_adjacent (Cons y ys) min_diff a b\n    | _ -> (a, b)\n    end\n\n  predicate adjacent (l: list int) (a:int) (b:int) =\n    match l with\n    | Cons x (Cons y xs) -> (x = a /\\ y = b) \\/ adjacent (Cons y xs) a b\n    | _ -> false\n    end\n\n  (* Main function: returns two closest elements in order (smaller, larger), or Nil if <2 elements *)\n  let find_closest_elements (numbers: list int) : list int\n    ensures {\n      length numbers < 2 -> result = Nil\n    }\n    ensures {\n      length numbers >= 2 ->\n        length result = 2 /\\\n        let a = nth result 0 in\n        let b = nth result 1 in\n        a <= b /\\\n        mem a numbers /\\ mem b numbers /\\\n        a <= b /\\\n        forall i j. i <> j /\\ 0 <= i < length numbers /\\ 0 <= j < length numbers -> abs (nth numbers i - nth numbers j) >= abs (a-b)\n    }\n  =\n    match sort numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = closest_adjacent (Cons x (Cons y xs)) (abs (x - y)) x y in\n      if a <= b then Cons a (Cons b Nil)\n      else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\nend\n"
        }
    ]
}