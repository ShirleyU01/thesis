{
    "ideas": [
        {
            "description": "The code is verified by adding pre- and postconditions to the recursive functions zip and compare_zip. For zip, we specify that the result's length is the minimum of the inputs' lengths and that nth accesses are correct up to that length. For compare_zip, we specify that the result's length matches the input, and each entry is 0 if the inputs are equal, or abs(a-b) otherwise. Variants are added for both recursive functions to prove termination. A lemma is added to connect compare_zip and zip to the top-level compare contract. All specifications are simple enough for SMT solvers.",
            "implementation": "module HumanEval152\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Min\n\n  (* zip: stop when either list ends; length is min of input lengths *)\n  let rec zip (l1 : list int) (l2 : list int) : list (int, int)\n    requires { true }\n    ensures { length result = min (length l1) (length l2) }\n    ensures { forall i:int. 0 <= i < min (length l1) (length l2) ->\n                let (a, b) = nth i result in a = nth i l1 /\\ b = nth i l2 }\n    variant { length l1 + length l2 }\n  = match l1, l2 with\n    | Nil, Nil -> Nil\n    | Cons x xs, Cons y ys -> Cons (x, y) (zip xs ys)\n    | _, _ -> Nil\n    end\n\n  (* compare_zip: for a list of (int,int) pairs, output list of abs diff or 0 *)\n  let rec compare_zip (zl : list (int, int)) : list int\n    requires { true }\n    ensures { length result = length zl }\n    ensures { forall i:int. 0 <= i < length zl ->\n                 let (a, b) = nth i zl in\n                 nth i result = (if a = b then 0 else abs (a - b)) }\n    variant { length zl }\n  = match zl with\n    | Nil -> Nil\n    | Cons (a, b) zs -> Cons (if a = b then 0 else abs (a - b)) (compare_zip zs)\n    end\n\n  (* Lemma: for lists l1, l2 of equal length, compare_zip (zip l1 l2) gives desired output *)\n  lemma compare_zip_zip_correct:\n    forall l1 l2: list int.\n      length l1 = length l2 ->\n      length (compare_zip (zip l1 l2)) = length l1 /\\\n      forall i:int. 0 <= i < length l1 ->\n        nth i (compare_zip (zip l1 l2)) = abs (nth i l1 - nth i l2)\n\n  let compare (l1 : list int) (l2 : list int) : list int =\n    requires { length l1 = length l2 }\n    ensures { length result = length l1 }\n    ensures { forall i: int. 0 <= i < length l1 -> nth i result = abs (nth i l1 - nth i l2)}\n    compare_zip (zip l1 l2)\nend\n"
        }
    ]
}