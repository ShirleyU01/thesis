{
    "ideas": [
        {
            "description": "Add full functional contracts to closest_pair and auxiliary, including preconditions for input length, postconditions for correctness, and variants for termination. Add postcondition to find_closest_elements to guarantee the returned pair are the closest elements, sorted. Add a variant to closest_pair for termination. The implementation is unchanged, only annotated for verification.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.NthNoOpt  \n\n  (*\n    closest_pair returns a triple (min_diff, a, b):\n    - min_diff is the minimum difference of any two elements in the original list l0\n    - (a, b) is a pair of elements in l0 with |a - b| = min_diff and a <= b\n    - min_diff is initally abs(x - y), a = min x y, b = max x y, for some x, y from input list\n    Pre: length l0 >= 2\n  *)\n  let rec closest_pair (l: list int) (min_diff: int) (a: int) (b: int) : (int, int, int)\n    requires { match l with Nil -> false | Cons _ Nil -> false | _ -> true end }\n    variant { length l }\n    ensures {\n      let orig_l = l in\n      let (md, aa, bb) = result in\n      (* 1. The returned pair (aa, bb) are members of the original list *)\n      Mem.occurs orig_l aa && Mem.occurs orig_l bb &&\n      (* 2. aa <= bb *)\n      aa <= bb &&\n      (* 3. md = abs(aa - bb) *)\n      md = abs (aa - bb) &&\n      (* 4. md is minimal difference of any two distinct elements of orig_l *)\n      (forall i j: int. 0 <= i < length orig_l /\\ 0 <= j < length orig_l /\\ i <> j ->\n        abs (NthNoOpt.nth orig_l i - NthNoOpt.nth orig_l j) >= md) &&\n      (* 5. There exists i, j such that aa = nth orig_l i, bb = nth orig_l j, i <> j *)\n      (exists i j: int. 0 <= i < length orig_l /\\ 0 <= j < length orig_l /\\ i <> j /\\\n        ((NthNoOpt.nth orig_l i = aa /\\ NthNoOpt.nth orig_l j = bb) \n        || (NthNoOpt.nth orig_l i = bb /\\ NthNoOpt.nth orig_l j = aa)))\n    }\n  =\n    match l with\n    | Cons x xs ->\n      let rec aux (ys: list int) (min_diff: int) (a: int) (b: int) : (int, int, int)\n        requires { true }\n        variant { length ys }\n        ensures {\n          let (md, aa, bb) = result in\n          (* 1. (aa, bb) are either the incoming (a, b) or a pair with x and y in ys, whichever is closer *)\n          (* 2. md = abs(aa - bb) *)\n          md = abs (aa - bb) &&\n          aa <= bb &&\n          (* 3. md <= min_diff *)\n          md <= min_diff &&\n          (* 4. aa, bb in (Cons x ys) *)\n          Mem.occurs (Cons x ys) aa && Mem.occurs (Cons x ys) bb\n        }\n      =\n        match ys with\n        | Nil -> (min_diff, a, b)\n        | Cons y ys' ->\n          let d = abs (x - y) in\n          if d < min_diff then aux ys' d (min x y) (max x y)\n          else aux ys' min_diff a b\n        end\n      in\n      let (new_min, new_a, new_b) = aux xs min_diff a b in\n      closest_pair xs new_min new_a new_b\n    | Nil -> (min_diff, a, b)\n    end\n\n  (*\n    Returns [smaller, larger] pair of closest elements of input.\n    Pre: length numbers >= 2\n    Post: result = [smaller, larger],\n      - both are in input\n      - smaller <= larger\n      - their abs diff is minimal among all pairs in input\n  *)\n  let find_closest_elements (numbers: list int) : list int\n    requires { match numbers with Cons _ (Cons _ _) -> true | _ -> false end }\n    ensures {\n      match numbers with\n      | Cons _ (Cons _ _) ->\n        match result with\n        | Cons a (Cons b Nil) ->\n          a <= b /\\\n          Mem.occurs numbers a /\\ Mem.occurs numbers b /\\\n          (forall i j: int. 0 <= i < length numbers /\\ 0 <= j < length numbers /\\ i <> j ->\n            abs (NthNoOpt.nth numbers i - NthNoOpt.nth numbers j) >= abs (a - b)) /\\\n          (exists i j: int. 0 <= i < length numbers /\\ 0 <= j < length numbers /\\ i <> j /\\\n            ((NthNoOpt.nth numbers i = a /\\ NthNoOpt.nth numbers j = b) \n            || (NthNoOpt.nth numbers i = b /\\ NthNoOpt.nth numbers j = a)))\n        | _ -> false\n        end\n      | _ -> result = Nil\n      end\n    }\n  =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b, c) = closest_pair (Cons x (Cons y xs)) (abs (x - y)) (min x y) (max x y) in\n      Cons b (Cons c Nil)\n    | _ -> Nil\n    end\nend"
        }
    ]
}