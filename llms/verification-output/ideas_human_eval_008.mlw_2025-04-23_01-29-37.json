{
    "ideas": [
        {
            "description": "Add pre- and postconditions as well as a variant to fold_sum_prod to prove correctness and termination. The pre- and postconditions make explicit that the function accumulates the sum and product of the list, and ensures that the sum and product at the end match those of the whole list. The variant proves termination for the recursive call. This suffices for the SMT solvers to prove the postconditions of sum_product automatically.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Sum\n\n  predicate product (l : list int) (q : int)\n    axiom product_base: forall l'. length l' = 0 <-> product l' 1\n    axiom product_rec : forall x', l', q'. product (Cons x' l') (q'*x') <-> product l' (q')\n\n  (* Helper function: computes (sum l + s, product l * p) *)\n  let rec fold_sum_prod (l: list int) (s: int) (p: int) : (int, int)\n    requires { true }\n    ensures  { let (s', p') = result in s' = sum l + s /\\ product l p' /\\ p' = p * (if length l = 0 then 1 else product_of_list l) }\n    variant  { length l }\n  =\n    match l with\n    | Nil -> (s, p)\n    | Cons x xs -> fold_sum_prod xs (s + x) (p * x)\n    end\n\n  (* Helper lemma for product function and product_of_list *)\n  function product_of_list (l: list int) : int = match l with | Nil -> 1 | Cons x xs -> x * product_of_list xs end\n\n  lemma product_nil : product Nil 1\n  lemma product_cons : forall x l q. product l q -> product (Cons x l) (q * x)\n  lemma product_charac : forall l q. product l q <-> q = product_of_list l\n\n  let sum_product (l: list int) : list int =\n    ensures { nth 0 result = sum l }\n    ensures { product l (nth 1 result) }\n    let (s, p) = fold_sum_prod l 0 1 in\n    Cons s (Cons p Nil)\nend\n"
        }
    ]
}