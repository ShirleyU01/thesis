{
    "ideas": [
        {
            "description": "Add contracts and variants to zip_index and add_zip to enable full automatic verification of the add function. Introduce a lemma connecting spec_add, add_zip, and zip_index, and strengthen the contracts for recursive functions. No changes to the implementation or the contract of add.",
            "implementation": "module HumanEval085\n  use int.Int\n  use int.EuclideanDivision\n  use list.List\n\n  function spec_add (l : list int) : int =\n    match l with\n    | Cons _ (Cons y ys) ->\n        (if mod y 2 = 0 then y else 0) + spec_add ys\n    | _ -> 0\n    end\n\n  predicate even (x:int) = mod x 2 = 0\n  predicate odd (x:int) = mod x 2 = 1\n\n  (* zip_index puts indices starting from i on each element *)\n  let rec zip_index (l : list int) (i : int) : list (int, int)\n    variant { length l }\n    ensures { forall j:int, x:int. 0 <= j < length l ->\n      nth (zip_index l i) j = (i + j, nth l j)\n    }\n    ensures { length result = length l }\n  =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> Cons (i, x) (zip_index xs (i + 1))\n    end\n\n  (* add_zip adds up x where index is odd and x is even *)\n  let rec add_zip (l : list (int, int)) : int\n    variant { length l }\n    ensures { result = (\n      let rec sum (l:list (int,int)) : int =\n        match l with\n        | Nil -> 0\n        | Cons (i, x) xs -> (if odd i && even x then x else 0) + sum xs\n        end\n      in sum l)\n    }\n  =\n    match l with\n    | Nil -> 0\n    | Cons (i, x) xs ->\n        let s = add_zip xs in\n        if mod i 2 = 1 && mod x 2 = 0 then x + s else s\n    end\n\n  (*\n     Lemma: For all l, spec_add l = add_zip (zip_index l 0)\n     Prove by induction on l.\n  *)\n  lemma spec_add_zip_index_corr:\n    forall l:list int. spec_add l = add_zip (zip_index l 0)\n\n  let add (l : list int) : int =\n    ensures { result = spec_add l }\n    add_zip (zip_index l 0)\nend\n"
        }
    ]
}