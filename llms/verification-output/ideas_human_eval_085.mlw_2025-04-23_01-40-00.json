{
    "ideas": [
        {
            "description": "Add a variant to the recursive function 'add' to prove termination. No further invariants, lemmas, or ghost code are required since the functional correctness and postcondition are already captured by the ensures clause and the function is structurally recursive over the list.",
            "implementation": "module HumanEval085\n  use int.Int\n  use int.EuclideanDivision\n  use list.List\n\n  function spec_add (l : list int) : int =\n    match l with\n    | Cons _ (Cons y ys) ->\n        (if mod y 2 = 0 then y else 0) + spec_add ys\n    | _ -> 0\n    end\n\n  let rec add (l : list int) : int\n    ensures { result = spec_add l }\n    variant { l }\n    = match l with\n      | Nil -> 0\n      | Cons _ Nil -> 0\n      | Cons _ (Cons y ys) ->\n          let to_add = if mod y 2 = 0 then y else 0 in\n          to_add + add ys\n      end\nend\n"
        }
    ]
}