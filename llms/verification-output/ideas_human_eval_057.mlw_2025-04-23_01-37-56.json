{
    "ideas": [
        {
            "description": "The specification for monotonic requires that the function returns true if and only if the list is monotonically increasing or decreasing. To verify this, add contracts to is_increasing to specify its behavior, and prove that is_increasing l <-> forall i. 0 <= i < length l - 1 -> nth i l <= nth (i+1) l. Similarly, is_increasing (reverse l) corresponds to decreasing. Add these postconditions to is_increasing, and state/prove two helper lemmas about reverse and nth to connect these properties. No changes are needed to the implementation, and only contracts/lemmas are added. All verification is handled by SMT solvers.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Reverse\n  use list.Length\n  use list.NthNoOpt\n\n  (* Helper lemma: nth (len-1-i) (reverse l) = nth i l *)\n  lemma nth_reverse:\n    forall l: list int, i: int.\n      0 <= i < length l -> nth i l = nth (length l - 1 - i) (reverse l)\n\n  (* Helper lemma: monotonicity of reverse relates to decreasing order *)\n  lemma is_increasing_reverse_decreasing:\n    forall l: list int.\n      (forall i: int. 0 <= i < length l - 1 -> nth i l > nth (i+1) l) <->\n      (forall i: int. 0 <= i < length l - 1 -> nth i (reverse l) < nth (i+1) (reverse l))\n\n  (* Postcondition for is_increasing *)\n  let rec is_increasing (l: list int) : bool\n    ensures { result <-> (forall i: int. 0 <= i < length l - 1 -> nth i l <= nth (i+1) l) }\n    variant { length l }\n  =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then is_increasing (Cons y r) else false\n    end\n  \n  let monotonic (l: list int) : bool =\n    ensures { result <-> ((forall i. 0 <= i < length l - 1 -> (nth i l < nth (i + 1) l)) \n                                \\/ (forall i. 0 <= i < length l - 1 -> (nth i l > nth (i + 1) l))) }\n    is_increasing l || is_increasing (reverse l)\nend\n"
        }
    ]
}