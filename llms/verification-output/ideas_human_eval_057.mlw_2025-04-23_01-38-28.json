{
    "ideas": [
        {
            "description": "Add postconditions to non_decreasing and non_increasing to capture their semantics, and introduce two lemmas connecting the output of these functions to the expected monotonicity properties (in terms of the list nth elements). This allows the SMT solvers to bridge the implementation with the contract required by monotonic. No change to the body of any function, and all verification is automatic.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec non_decreasing (l: list int) : bool\n    ensures { result <-> (forall i: int. 0 <= i < length l - 1 -> nth i l <= nth (i+1) l) }\n    variant { l }\n  = match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then non_decreasing (Cons y r) else false\n    end\n\n  let rec non_increasing (l: list int) : bool\n    ensures { result <-> (forall i: int. 0 <= i < length l - 1 -> nth i l >= nth (i+1) l) }\n    variant { l }\n  = match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x >= y then non_increasing (Cons y r) else false\n    end\n\n  lemma non_decreasing_semantics:\n    forall l: list int. non_decreasing l <-> (forall i: int. 0 <= i < length l - 1 -> nth i l <= nth (i+1) l)\n\n  lemma non_increasing_semantics:\n    forall l: list int. non_increasing l <-> (forall i: int. 0 <= i < length l - 1 -> nth i l >= nth (i+1) l)\n\n  let monotonic (l: list int) : bool\n      ensures { result <-> ((forall i. 0 <= i < length l - 1 -> (nth i l <= nth (i + 1) l)) \n                                \\/ (forall i. 0 <= i < length l - 1 -> (nth i l >= nth (i + 1) l))) }\n  =\n    non_decreasing l || non_increasing l\nend\n"
        }
    ]
}