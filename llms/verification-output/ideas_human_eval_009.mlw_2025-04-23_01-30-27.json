{
    "ideas": [
        {
            "description": "Add a variant to rolling_max_aux for termination, and add contract to rolling_max_aux to support the postcondition proof for rolling_max. Prove that the result at each index is at least the input value at that index, and that each result value is a value from the prefix of the input.",
            "implementation": "module HumanEval009\n  use int.Int\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  (* Ghost function to get the prefix of a list up to index i (exclusive) *)\n  function prefix (l: list int) (i: int) : list int =\n    if i <= 0 then Nil else\n      match l with\n      | Nil -> Nil\n      | Cons x xs -> Cons x (prefix xs (i-1))\n      end\n\n  (* Contract for rolling_max_aux: result is a list of same length as input;\n     for each i, result[i] is the maximum element in the original prefix up to i *)\n  let rec rolling_max_aux (l: list int) (current: int) : list int\n    variant { length l }\n    ensures { length result = length l }\n    ensures { forall i. 0 <= i < length l ->\n      nth i result = max (current) (fold_left max l i)\n    }\n    ensures { forall i. 0 <= i < length l -> nth i result >= nth i l }\n    ensures { forall i. 0 <= i < length l ->\n      exists j. 0 <= j <= i /\\ nth i result = (if j = 0 then current else nth (j-1) l)\n    }\n  =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let new_max = max current x in\n      Cons new_max (rolling_max_aux xs new_max)\n    end\n\n  (* Helper: maximum in prefix of length i of list l, starting with acc *)\n  function fold_left (f: int -> int -> int) (l: list int) (n: int) : int =\n    match l, n with\n    | _, n when n <= 0 -> 0  (* not used, just a stub for max *)\n    | Nil, _ -> 0\n    | Cons x xs, n ->\n      if n = 1 then x else max x (fold_left f xs (n-1))\n    end\n\n  let rolling_max (l: list int) : list int =\n    ensures { forall i. 0 <= i < length l -> nth i result >= nth i l }\n    ensures { forall i. 0 <= i < length l -> exists j. 0 <= j <= i /\\ nth i result = nth j l }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> Cons x (rolling_max_aux xs x)\n    end\nend\n"
        }
    ]
}