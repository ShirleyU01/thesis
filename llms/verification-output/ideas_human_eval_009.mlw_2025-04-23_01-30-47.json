{
    "ideas": [
        {
            "description": "Add contract and variant to rolling_max_explicit to support verification of rolling_max. Add a lemma to relate nth of result to maximum of prefix, to allow SMT to verify postconditions.",
            "implementation": "module HumanEval009\n  use int.Int\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  (*\n    Helper lemma: The nth i of rolling_max_explicit xs cur is always the maximum of nth j xs (0 <= j <= i) and cur.\n    This lemma helps relate the algorithm to the specification in rolling_max.\n  *)\n  lemma nth_rolling_max_explicit:\n    forall l: list int, cur: int, i: int.\n      0 <= i < length l ->\n      nth i (rolling_max_explicit l cur) =\n        max cur (fold_left max (take (i+1) l) cur)\n\n  (*\n    Contract for rolling_max_explicit: For any index i, the ith element of result is >= nth i l (is a maximum so far),\n    and is equal to some element of l or cur.\n    We also add a variant for termination.\n  *)\n  let rec rolling_max_explicit (l: list int) (cur: int) : list int\n    ensures { length result = length l }\n    ensures { forall i. 0 <= i < length l -> nth i result >= nth i l }\n    ensures { forall i. 0 <= i < length l ->\n                exists j. -1 <= j <= i /\\n                  (j = -1 -> nth i result = cur) /\\\n                  (j >= 0 -> nth i result = nth j l)\n             }\n    variant { length l }\n  =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let m = max cur x in\n      Cons m (rolling_max_explicit xs m)\n    end\n\n  let rolling_max (l: list int) : list int =\n    ensures { forall i . 0 <= i < length l -> nth i result >= nth i l }\n    ensures { forall i . 0 <= i < length l -> exists j. 0 <= j <= i /\\ nth i result = nth j l }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> Cons x (rolling_max_explicit xs x)\n    end\nend\n"
        }
    ]
}