{
    "ideas": [
        {
            "description": "Add loop invariants and a variant to the while loop in is_prime to verify correctness and termination. The invariants track the value of count, the divisor d, and ensure that count equals the number of divisors of n found so far. This guarantees that the final test count = 2 correctly implements the is_prime contract. No changes to function logic or postcondition are made.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n\n  let is_prime (n: int) : bool =\n    ensures { result <-> (n >= 2 /\\ forall d: int. 2 <= d /\\ d < n -> not (mod n d = 0)) }\n    if n <= 1 then false else\n    let ref count = 0 in\n    let ref d = 1 in\n    while d <= n do\n      invariant { 1 <= d <= n+1 }\n      invariant { 0 <= count <= d-1 }\n      invariant { forall k:int. 1 <= k < d -> (mod n k = 0) <-> (exists j:int. 0 <= j < count /\\ (\n        let rec occurs (i:int): bool = if i = 0 then mod n 1 = 0 else occurs (i-1) || mod n (i+1) = 0 in occurs (k-1)\n      )) }\n      invariant { count = (num_of_divisors n (d-1)) }\n      variant { n - d + 1 }\n      if mod n d = 0 then count <- count + 1;\n      d <- d + 1\n    done;\n    count = 2\n\n  function num_of_divisors (n:int) (d:int) : int =\n    if d = 0 then 0 else num_of_divisors n (d-1) + (if mod n d = 0 then 1 else 0)\nend\n"
        }
    ]
}