{
    "ideas": [
        {
            "description": "Add a variant to the recursive function 'filter_pos' to prove termination. No other changes are needed; the original ensures clauses are correct and sufficient. The variant is the length of the input list, which strictly decreases with each recursive call. This allows the code to be automatically verified by SMT solvers.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Mem\n\n  let rec filter_pos (f: int -> bool) (l: list int) : list int\n    variant { length l }\n    ensures { length l >= length result }\n    ensures { forall x . (mem x l /\\ x > 0) -> mem x result }\n    ensures { forall x . mem x result -> x > 0 }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if f x then Cons x (filter_pos f xs) else filter_pos f xs\n    end\n\n  let get_positive (l: list int) : list int =\n    filter_pos (fun x -> x > 0) l\nend\n"
        }
    ]
}