{
    "ideas": [
        {
            "description": "Add a variant to the recursive function sum_product to prove termination. Add supporting lemmas for sum and product correctness to help SMT solvers verify the ensures clauses. The implementation, postconditions, and logic are otherwise unchanged.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Sum\n\n  predicate product (l : list int) (q : int)\n    axiom product_base: forall l'. length l' = 0 <-> product l' 1\n    axiom product_rec : forall x', l', q'. product (Cons x' l') (q'*x') <-> product l' (q')\n\n  (* Lemma: The sum of l is equal to the sum computed recursively. *)\n  lemma sum_cons:\n    forall x: int, xs: list int. sum (Cons x xs) = x + sum xs\n\n  (* Lemma: The product predicate matches the usual definition of product over lists. *)\n  predicate prod (l: list int) (acc: int) =\n    match l with\n    | Nil -> acc = 1\n    | Cons x xs -> exists p: int. prod xs p /\\ acc = x * p\n    end\n\n  lemma product_correct:\n    forall l: list int, q: int. product l q <->\n      (match l with Nil -> q = 1 | Cons x xs -> exists p: int. product xs p /\\ q = x * p end)\n\n  let rec sum_product (l: list int) : list int\n    variant { length l }\n    ensures { nth 0 result = sum l }\n    ensures { product l (nth 1 result) }\n  =\n    match l with\n    | Nil -> Cons 0 (Cons 1 Nil)\n    | Cons x xs ->\n        let Cons s (Cons p Nil) = sum_product xs in\n        Cons (x + s) (Cons (x * p) Nil)\n    end\nend\n"
        }
    ]
}