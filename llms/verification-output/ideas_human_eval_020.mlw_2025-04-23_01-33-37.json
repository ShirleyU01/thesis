{
    "ideas": [
        {
            "description": "Fully specified and verified code for find_closest_elements. We add pre- and postconditions to all relevant functions. We ensure sort returns an ordered list, insert preserves sortedness, and adjacent_min finds the minimal adjacent difference. We use ghost code and auxiliary predicates for sortedness, sublist, and adjacent pairs. The main function is specified to return two closest elements in sorted order.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.NthNoOpt\n  use list.Append\n  use ref.Ref\n\n  predicate sorted (l: list int) =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x <= y /\\ sorted (Cons y ys)\n    end\n\n  predicate sublist (l1: list int) (l2: list int) =\n    forall x: int. mem x l1 -> mem x l2 /\\ length l1 = length l2\n\n  predicate adjacent_pair (l: list int) (a: int) (b: int) =\n    match l with\n    | Cons x (Cons y xs) -> (x = a /\\ y = b) \\/ adjacent_pair (Cons y xs) a b\n    | _ -> false\n    end\n\n  (* insert x into sorted l *)\n  let rec insert (x:int) (l:list int) : list int\n    ensures { sorted l -> sorted result }\n    ensures { mem x result }\n    ensures { forall y:int. mem y l -> mem y result }\n    ensures { length result = length l + 1 }\n  =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n    end\n\n  (* sort returns the sorted permutation of l *)\n  let rec sort (l:list int) : list int\n    ensures { sorted result }\n    ensures { forall x:int. mem x l <-> mem x result }\n    ensures { length result = length l }\n  =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (sort xs)\n    end\n\n  (* Find adjacent pair with minimal difference *)\n  let rec adjacent_min (l: list int) (min_diff: int) (a: int) (b: int) : (int, int)\n    requires { sorted l }\n    requires { length l >= 2 }\n    requires { adjacent_pair l a b }\n    variant { length l }\n    ensures { let (x, y) = result in\n      adjacent_pair l x y /\\ abs (x - y) <= min_diff /\\\n      forall i: int, j: int. 0 <= i < length l - 1 /\\ 0 <= j < length l - 1 ->\n        abs (nth l i - nth l (i+1)) >= abs (x - y)\n    }\n  =\n    match l with\n    | Cons x (Cons y xs) ->\n      let d = abs (x - y) in\n      if d < min_diff then adjacent_min (Cons y xs) d x y else adjacent_min (Cons y xs) min_diff a b\n    | _ -> (a, b)\n    end\n\n  (* Main function: find the closest elements *)\n  let find_closest_elements (numbers: list int) : list int\n    requires { length numbers >= 2 }\n    ensures {\n      match result with\n      | Cons a (Cons b Nil) ->\n          a <= b /\\\n          mem a numbers /\\ mem b numbers /\\\n          forall (x: int) (y: int). mem x numbers /\\ mem y numbers /\\ x <> y ->\n            abs (x - y) >= abs (a - b)\n      | Nil -> true\n      | _ -> false\n      end\n    }\n  =\n    match sort numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = adjacent_min (Cons x (Cons y xs)) (abs (x - y)) x y in\n      if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\n\nend\n"
        }
    ]
}