{
    "ideas": [
        {
            "description": "Using a single pass with a check for both increasing and decreasing conditions.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x xs -> \n      let rec aux (prev : int) (incr : bool) (decr : bool) (lst : list int) : bool =\n        match lst with\n        | Nil -> incr || decr\n        | Cons y ys ->\n          aux y (incr && y >= prev) (decr && y <= prev) ys\n        end\n      in aux x true true xs\n    end\nend"
        },
        {
            "description": "Using two separate passes: one to check for increasing, another for decreasing.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec is_increasing (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x <= y && is_increasing (Cons y ys)\n    end\n\n  let rec is_decreasing (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x >= y && is_decreasing (Cons y ys)\n    end\n\n  let monotonic (l : list int) : bool =\n    is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Using a recursive helper function with pattern matching to determine monotonicity.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec check_monotonic (l : list int) (incr : bool) (decr : bool) : bool =\n    match l with\n    | Nil -> incr || decr\n    | Cons x Nil -> incr || decr\n    | Cons x (Cons y ys) ->\n      check_monotonic (Cons y ys) (incr && x <= y) (decr && x >= y)\n    end\n\n  let monotonic (l : list int) : bool =\n    check_monotonic l true true\nend"
        },
        {
            "description": "Using an iterative approach with a loop to track monotonic properties.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l : list int) : bool =\n    let ref incr = true in\n    let ref decr = true in\n    let ref prev = 0 in\n    let rec loop lst is_first =\n      match lst with\n      | Nil -> incr || decr\n      | Cons x xs ->\n        if not is_first then begin\n          incr <- incr && prev <= x;\n          decr <- decr && prev >= x;\n        end;\n        prev <- x;\n        loop xs false\n      end\n    in loop l true\nend"
        },
        {
            "description": "Using a fold_left approach to determine if the list is monotonic.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonically_fold (acc : (bool, bool, int option)) (e : int) : (bool, bool, int option) =\n    let (incr, decr, prev) = acc in\n    match prev with\n    | None -> (true, true, Some e)\n    | Some p -> (incr && p <= e, decr && p >= e, Some e)\n    end\n\n  let monotonic (l : list int) : bool =\n    let (incr, decr, _) = fold_left monotonically_fold (true, true, None) l in\n    incr || decr\nend"
        },
        {
            "description": "Using two separate recursive functions to check monotonicity, one for increasing and one for decreasing.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec is_increasing (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x <= y && is_increasing (Cons y ys)\n    end\n\n  let rec is_decreasing (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> x >= y && is_decreasing (Cons y ys)\n    end\n\n  let monotonic (l : list int) : bool =\n    is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Using a single recursive function that tracks both increasing and decreasing states with a tuple.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec check_monotonic (l : list int) (state : (bool, bool)) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) ->\n      let (incr, decr) = state in\n      check_monotonic (Cons y ys) (incr && x <= y, decr && x >= y)\n    end\n\n  let monotonic (l : list int) : bool =\n    check_monotonic l (true, true)\nend"
        },
        {
            "description": "Using a while loop to iterate through the list and check for monotonicity.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l : list int) : bool =\n    let ref incr = true in\n    let ref decr = true in\n    let ref prev = 0 in\n    let ref lst = l in\n    let ref is_first = true in\n    while is_first || lst <> Nil do\n      match lst with\n      | Nil -> ()\n      | Cons x xs ->\n        if not is_first then begin\n          incr <- incr && prev <= x;\n          decr <- decr && prev >= x;\n        end;\n        prev <- x;\n        lst <- xs;\n        is_first <- false;\n      end\n    done;\n    incr || decr\nend"
        },
        {
            "description": "Using a combination of pattern matching and auxiliary function to check the monotonicity in a single traversal.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec aux_check (prev : int) (incr : bool) (decr : bool) (l : list int) : bool =\n    match l with\n    | Nil -> incr || decr\n    | Cons x xs ->\n      aux_check x (incr && x >= prev) (decr && x <= prev) xs\n    end\n\n  let monotonic (l : list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x xs -> aux_check x true true xs\n    end\nend"
        },
        {
            "description": "Using a functional approach with map and fold to determine if the list is monotonic.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l : list int) : bool =\n    let rec map_adjacent (l : list int) : list (int, int) =\n      match l with\n      | Nil -> Nil\n      | Cons x Nil -> Nil\n      | Cons x (Cons y ys) -> Cons (x, y) (map_adjacent (Cons y ys))\n      end\n    in\n    let check_pair (p : (int, int)) : (bool, bool) -> (bool, bool) =\n      let (x, y) = p in\n      fun (incr, decr) -> (incr && x <= y, decr && x >= y)\n    in\n    let (is_incr, is_decr) = fold_left check_pair (true, true) (map_adjacent l) in\n    is_incr || is_decr\nend"
        }
    ]
}