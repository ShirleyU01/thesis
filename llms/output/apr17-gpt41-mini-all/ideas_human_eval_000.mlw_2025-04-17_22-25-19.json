{
    "ideas": [
        {
            "description": "Using two nested for-loops iterating over list indices to compare every pair of elements and return true if any two are closer than the threshold.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.Length\n\n  let rec nth_my (n:int) (l: list real) : real =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let n = length numbers in\n    let rec outer i =\n      if i >= n then false else\n      let rec inner j =\n        if j >= n then false else\n        if abs (nth_my i numbers -. nth_my j numbers) < threshold then true else inner (j + 1)\n      in\n      if inner (i + 1) then true else outer (i + 1)\n    in\n    outer 0\nend"
        },
        {
            "description": "Using recursion with pattern matching to check pairs by splitting the list into head and tail, comparing head to all elements in tail, then recurring on the tail.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec has_close_elements (numbers: list real) (threshold: real) : bool =\n    match numbers with\n    | Nil -> false\n    | Cons x xs ->\n      let rec check_all l =\n        match l with\n        | Nil -> false\n        | Cons y ys ->\n          if abs (x -. y) < threshold then true else check_all ys\n        end\n      in\n      if check_all xs then true else has_close_elements xs threshold\n    end\nend"
        },
        {
            "description": "Sort the list first, then check only adjacent pairs for closeness since any closer elements must be adjacent in sorted order.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.Sorted\n  use list.Length\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec insertion_sort (l: list real) : list real =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let rec insert elt l2 =\n        match l2 with\n        | Nil -> Cons elt Nil\n        | Cons y ys -> if elt <= y then Cons elt l2 else Cons y (insert elt ys)\n        end\n      in\n      insert x (insertion_sort xs)\n    end\n\n  let rec check_adjacent (l: list real) (threshold: real) : bool =\n    match l with\n    | Cons x (Cons y ys) -> if abs (x -. y) < threshold then true else check_adjacent (Cons y ys) threshold\n    | _ -> false\n    end\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let sorted = insertion_sort numbers in\n    check_adjacent sorted threshold\nend"
        },
        {
            "description": "Using a helper recursive function with an accumulator list to keep track of seen elements and compare each new element against all seen elements for closeness.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec any_close (seen: list real) (remaining: list real) (threshold: real) : bool =\n    match remaining with\n    | Nil -> false\n    | Cons x xs ->\n      let rec check_seen l =\n        match l with\n        | Nil -> false\n        | Cons y ys -> if abs (x -. y) < threshold then true else check_seen ys\n        end\n      in\n      if check_seen seen then true else any_close (Cons x seen) xs threshold\n    end\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    any_close Nil numbers threshold\nend"
        },
        {
            "description": "Using an integer index and recursive functions to simulate nested loops by manually indexing elements with a custom nth_my function to compare all pairs.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list real) : real =\n    requires { length l > 0 }\n    requires { 0 <= n /\\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner_loop (numbers: list real) (threshold: real) (i: int) (j: int) (len: int) : bool =\n    if j >= len then false else\n    if abs (nth_my i numbers -. nth_my j numbers) < threshold then true else inner_loop numbers threshold i (j + 1) len\n\n  let rec outer_loop (numbers: list real) (threshold: real) (i: int) (len: int) : bool =\n    if i >= len then false else\n    if inner_loop numbers threshold i (i + 1) len then true else outer_loop numbers threshold (i + 1) len\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let len = length numbers in\n    outer_loop numbers threshold 0 len\nend"
        },
        {
            "description": "Use fold_left over the list with an accumulator list to accumulate elements seen so far and check closeness to each newly folded element.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.FoldLeft\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec check_close (seen: list real) (x: real) (threshold: real) : bool =\n    match seen with\n    | Nil -> false\n    | Cons y ys -> if abs (x -. y) < threshold then true else check_close ys x threshold\n    end\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let f acc x =\n      match acc with\n      | (found, seen) ->\n        if found then (true, seen)\n        else if check_close seen x threshold then (true, seen) else (false, Cons x seen)\n    in\n    fst (fold_left f (false, Nil) numbers)\nend"
        },
        {
            "description": "Use a recursive helper that checks closeness of the head to all elements in the tail, implementing early return with boolean short-circuiting.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec check_head_tail (head: real) (tail: list real) (threshold: real) : bool =\n    match tail with\n    | Nil -> false\n    | Cons y ys -> if abs (head -. y) < threshold then true else check_head_tail head ys threshold\n    end\n\n  let rec has_close_elements (numbers: list real) (threshold: real) : bool =\n    match numbers with\n    | Nil -> false\n    | Cons x xs -> if check_head_tail x xs threshold then true else has_close_elements xs threshold\n    end\nend"
        },
        {
            "description": "Use an explicit while-like recursive function with an index counter for the outer loop and an inner loop for comparison, avoiding nested recursion by manual index management.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list real) : real =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner (numbers: list real) (threshold: real) (i: int) (j: int) (len: int) : bool =\n    if j >= len then false else\n    if abs (nth_my i numbers -. nth_my j numbers) < threshold then true else inner numbers threshold i (j + 1) len\n\n  let rec outer (numbers: list real) (threshold: real) (i: int) (len: int) : bool =\n    if i >= len then false else\n    if inner numbers threshold i (i + 1) len then true else outer numbers threshold (i + 1) len\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let len = length numbers in\n    outer numbers threshold 0 len\nend"
        },
        {
            "description": "Use recursion with an auxiliary function that compares the first element with the rest and then recursively calls itself on the tail, using pattern matching and if-then-else.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n\n  let rec abs (x: real) : real = if x < 0.0 then -.x else x\n\n  let rec compare_head_rest (head: real) (l: list real) (threshold: real) : bool =\n    match l with\n    | Nil -> false\n    | Cons x xs -> if abs (head -. x) < threshold then true else compare_head_rest head xs threshold\n    end\n\n  let rec has_close_elements (numbers: list real) (threshold: real) : bool =\n    match numbers with\n    | Nil -> false\n    | Cons x xs -> begin\n        if compare_head_rest x xs threshold then true else has_close_elements xs threshold\n      end\n    end\nend"
        },
        {
            "description": "Use a tail-recursive helper function with two pointers (indices) that iterate through the list to check pairs, mimicking nested loops in a tail-recursive style.",
            "implementation": "module HumanEval000\n\n  use real.Real\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list real) : real =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner_tail (numbers: list real) (threshold: real) (i: int) (j: int) (len: int) : bool =\n    if j >= len then false else\n    if abs (nth_my i numbers -. nth_my j numbers) < threshold then true else inner_tail numbers threshold i (j + 1) len\n\n  let rec outer_tail (numbers: list real) (threshold: real) (i: int) (len: int) : bool =\n    if i >= len then false else\n    if inner_tail numbers threshold i (i + 1) len then true else outer_tail numbers threshold (i + 1) len\n\n  let has_close_elements (numbers: list real) (threshold: real) : bool =\n    let len = length numbers in\n    outer_tail numbers threshold 0 len\nend"
        }
    ]
}