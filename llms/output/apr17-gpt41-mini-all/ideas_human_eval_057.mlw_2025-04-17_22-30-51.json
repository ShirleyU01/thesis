{
    "ideas": [
        {
            "description": "Recursive approach with two helper functions checking strictly non-decreasing and non-increasing sequences separately, then combining results.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  let rec non_decreasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> if x <= y then non_decreasing (Cons y ys) else false\n    end\n\n  let rec non_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x Nil -> true\n    | Cons x (Cons y ys) -> if x >= y then non_increasing (Cons y ys) else false\n    end\n\n  let monotonic (l: list int) : bool =\n    non_decreasing l || non_increasing l\nend"
        },
        {
            "description": "Single recursive function that passes along two boolean flags indicating if the list is non-decreasing and non-increasing simultaneously.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  let rec aux (l: list int) (nondec: bool) (noninc: bool) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y ys) ->\n        let nondec' = nondec && (x <= y) in\n        let noninc' = noninc && (x >= y) in\n        if not nondec' && not noninc' then false else aux (Cons y ys) nondec' noninc'\n    end\n\n  let monotonic (l: list int) : bool =\n    aux l true true\nend"
        },
        {
            "description": "Iterative style using an auxiliary recursive function that compares each adjacent pair and returns false if monotonicity is violated.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  let rec check_non_decreasing (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> if x <= y then check_non_decreasing (Cons y ys) else false\n    end\n\n  let rec check_non_increasing (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> if x >= y then check_non_increasing (Cons y ys) else false\n    end\n\n  let monotonic (l: list int) : bool =\n    check_non_decreasing l || check_non_increasing l\nend"
        },
        {
            "description": "Use list length and a custom nth_my function to iterate through list indices and check monotonicity with two boolean accumulators.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let monotonic (l: list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let rec aux i nondec noninc =\n      if i = n - 1 then nondec || noninc else\n      let a = nth_my i l in\n      let b = nth_my (i + 1) l in\n      aux (i + 1) (nondec && (a <= b)) (noninc && (a >= b))\n    in\n    aux 0 true true\nend"
        },
        {
            "description": "Reverse the list and check if the reversed list is sorted ascending or descending using built-in sorted predicates.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n  use list.SortedInt\n  use list.Reverse\n\n  let monotonic (l: list int) : bool =\n    sorted_int l || sorted_int (reverse l)\nend"
        },
        {
            "description": "Use fold_left to accumulate flags for monotonicity by iterating through pairs of elements in the list.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n  use list.FoldLeft\n\n  let rec pairwise (l: list int) : list (int, int) =\n    match l with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y ys) -> Cons (x, y) (pairwise (Cons y ys))\n    end\n\n  let monotonic (l: list int) : bool =\n    let pairs = pairwise l in\n    let f (nondec, noninc) (a, b) = (nondec && (a <= b), noninc && (a >= b)) in\n    let (nd, ni) = fold_left f (true, true) pairs in\n    nd || ni\nend"
        },
        {
            "description": "Recursive function that compares the first two elements and recursively checks the rest of the list with updated monotonicity direction flags.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  let rec check_direction (l: list int) (increasing: bool) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) ->\n        if increasing then\n          if x <= y then check_direction (Cons y ys) true else false\n        else\n          if x >= y then check_direction (Cons y ys) false else false\n    end\n\n  let monotonic (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> check_direction l true || check_direction l false\n    end\nend"
        },
        {
            "description": "Define an auxiliary recursive function with an accumulator that stores the previous element and a mode indicator (increasing, decreasing, or unknown).",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  type mode = Unknown | Increasing | Decreasing\n\n  let rec aux (l: list int) (prev: int) (m: mode) : bool =\n    match l with\n    | Nil -> true\n    | Cons x xs ->\n        match m with\n        | Unknown ->\n            if x > prev then aux xs x Increasing\n            else if x < prev then aux xs x Decreasing\n            else aux xs x Unknown\n        | Increasing -> if x >= prev then aux xs x Increasing else false\n        | Decreasing -> if x <= prev then aux xs x Decreasing else false\n        end\n\n  let monotonic (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> aux (Cons y ys) x Unknown\n    end\nend"
        },
        {
            "description": "Use pattern matching and mutually recursive functions to check monotonicity by splitting into increasing and decreasing checks.",
            "implementation": "module HumanEval057\n\n  use int.Int\n  use list.List\n\n  let rec inc (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> if x <= y then inc (Cons y ys) else false\n    end\n\n  let rec dec (l: list int) : bool =\n    match l with\n    | Nil | Cons _ Nil -> true\n    | Cons x (Cons y ys) -> if x >= y then dec (Cons y ys) else false\n    end\n\n  let monotonic (l: list int) : bool =\n    inc l || dec l\nend"
        }
    ]
}