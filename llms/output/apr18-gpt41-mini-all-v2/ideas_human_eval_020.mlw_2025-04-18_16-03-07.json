{
    "ideas": [
        {
            "description": "Idea 1: Use sorting the list first, then scan adjacent pairs to find the minimum difference pair. Return the pair in order.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.Map\n  use list.Reverse\n  use list.SortedInt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_closest_elements_aux (l : list int) (min_diff : int) (best_pair : (int * int)) (idx : int) : (int * int) =\n    requires { length l > 1 }\n    requires { 0 <= idx /\n               idx < length l - 1 }\n    variant { length l - idx }\n    match l with\n    | Cons _ _ ->\n      if idx = length l - 2 then\n        best_pair\n      else\n        let a = nth_my idx l in\n        let b = nth_my (idx + 1) l in\n        let diff = abs (b - a) in\n        if diff < min_diff then\n          find_closest_elements_aux l diff (min a b, max a b) (idx + 1)\n        else\n          find_closest_elements_aux l min_diff best_pair (idx + 1)\n    end\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = List.sort Int.compare numbers in\n    let (x, y) = find_closest_elements_aux sorted (abs (nth_my 1 sorted - nth_my 0 sorted)) (nth_my 0 sorted, nth_my 1 sorted) 0 in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 2: Use a recursive function that compares each pair with all subsequent elements to find the closest pair, without sorting.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_min_pair_from_idx (l : list int) (i : int) (j : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { length l > 1 }\n    requires { 0 <= i < length l - 1 }\n    requires { i < j <= length l }\n    variant { length l - j }\n    if j = length l then\n      best_pair\n    else\n      let a = nth_my i l in\n      let b = nth_my j l in\n      let diff = abs (b - a) in\n      if diff < min_diff then\n        find_min_pair_from_idx l i (j + 1) diff (min a b, max a b)\n      else\n        find_min_pair_from_idx l i (j + 1) min_diff best_pair\n\n  let rec find_closest_elements_rec (l : list int) (i : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { length l >= 2 }\n    requires { 0 <= i < length l - 1 }\n    variant { length l - i }\n    if i = length l - 1 then\n      best_pair\n    else\n      let candidate_pair = find_min_pair_from_idx l i (i + 1) min_diff best_pair in\n      let new_min_diff = abs (snd candidate_pair - fst candidate_pair) in\n      if new_min_diff < min_diff then\n        find_closest_elements_rec l (i + 1) new_min_diff candidate_pair\n      else\n        find_closest_elements_rec l (i + 1) min_diff best_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let first = nth_my 0 numbers in\n    let second = nth_my 1 numbers in\n    let init_diff = abs (second - first) in\n    let (x, y) = find_closest_elements_rec numbers 0 init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 3: Use an accumulator recursive function that traverses the list comparing each pair of adjacent elements and keeps track of the best pair found so far. Sort list first to only check adjacent pairs.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.SortedInt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec aux (l : list int) (idx : int) (len : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { idx < len }\n    variant { len - idx }\n    if idx = len - 1 then\n      best_pair\n    else\n      let a = nth_my idx l in\n      let b = nth_my (idx + 1) l in\n      let diff = abs (b - a) in\n      let (new_min, new_pair) =\n        if diff < min_diff then\n          (diff, (min a b, max a b))\n        else\n          (min_diff, best_pair)\n      in\n      aux l (idx + 1) len new_min new_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = List.sort Int.compare numbers in\n    let len = length sorted in\n    let first = nth_my 0 sorted in\n    let second = nth_my 1 sorted in\n    let init_diff = abs (second - first) in\n    let (x, y) = aux sorted 0 len init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 4: Use explicit nested loops via recursion to compare all pairs and keep track of the closest pair, without sorting.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner_loop (l : list int) (i : int) (j : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { length l > 1 }\n    requires { 0 <= i < length l - 1 }\n    requires { i < j <= length l }\n    variant { length l - j }\n    if j = length l then\n      best_pair\n    else\n      let a = nth_my i l in\n      let b = nth_my j l in\n      let diff = abs (b - a) in\n      if diff < min_diff then\n        inner_loop l i (j + 1) diff (min a b, max a b)\n      else\n        inner_loop l i (j + 1) min_diff best_pair\n\n  let rec outer_loop (l : list int) (i : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { length l >= 2 }\n    requires { 0 <= i < length l - 1 }\n    variant { length l - i }\n    if i = length l - 1 then\n      best_pair\n    else\n      let candidate_pair = inner_loop l i (i + 1) min_diff best_pair in\n      let new_min_diff = abs (snd candidate_pair - fst candidate_pair) in\n      if new_min_diff < min_diff then\n        outer_loop l (i + 1) new_min_diff candidate_pair\n      else\n        outer_loop l (i + 1) min_diff best_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let first = nth_my 0 numbers in\n    let second = nth_my 1 numbers in\n    let init_diff = abs (second - first) in\n    let (x, y) = outer_loop numbers 0 init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 5: Use pattern matching recursion that compares first element with all others and recursively find closest in tail, then compare results.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec closest_to_x (x : int) (l : list int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    match l with\n    | Nil -> best_pair\n    | Cons y ys ->\n      let diff = abs (x - y) in\n      let (new_diff, new_pair) =\n        if diff < min_diff then (diff, (min x y, max x y)) else (min_diff, best_pair)\n      in\n      closest_to_x x ys new_diff new_pair\n    end\n\n  let rec find_closest_elements_rec (l : list int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    match l with\n    | Cons x Nil -> best_pair\n    | Cons x xs ->\n      let candidate_pair = closest_to_x x xs min_diff best_pair in\n      let new_min_diff = abs (snd candidate_pair - fst candidate_pair) in\n      let tail_pair = find_closest_elements_rec xs new_min_diff candidate_pair in\n      let tail_diff = abs (snd tail_pair - fst tail_pair) in\n      if new_min_diff <= tail_diff then candidate_pair else tail_pair\n    | Nil -> best_pair\n    end\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let init_diff = abs (y - x) in\n      let init_pair = (min x y, max x y) in\n      let (a, b) = find_closest_elements_rec numbers init_diff init_pair in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Idea 6: Use sorting and then fold-like recursion with accumulator to find closest adjacent pair, avoiding explicit loops.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.SortedInt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec fold_closest (l : list int) (idx : int) (len : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { idx < len }\n    variant { len - idx }\n    if idx = len - 1 then\n      best_pair\n    else\n      let a = nth_my idx l in\n      let b = nth_my (idx + 1) l in\n      let diff = abs (b - a) in\n      let (new_diff, new_pair) =\n        if diff < min_diff then (diff, (min a b, max a b)) else (min_diff, best_pair)\n      in\n      fold_closest l (idx + 1) len new_diff new_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = List.sort Int.compare numbers in\n    let len = length sorted in\n    let first = nth_my 0 sorted in\n    let second = nth_my 1 sorted in\n    let init_diff = abs (second - first) in\n    let (x, y) = fold_closest sorted 0 len init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 7: Use an imperative style with references and while loops to iterate through all pairs, updating closest pair found.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 1 numbers - nth_my 0 numbers) in\n    let ref best_x = min (nth_my 0 numbers) (nth_my 1 numbers) in\n    let ref best_y = max (nth_my 0 numbers) (nth_my 1 numbers) in\n    let ref i = 0 in\n    while !i < n do\n      let ref j = !i + 1 in\n      while !j < n do\n        let a = nth_my !i numbers in\n        let b = nth_my !j numbers in\n        let diff = abs (b - a) in\n        if diff < !min_diff then\n          begin\n            min_diff := diff;\n            best_x := min a b;\n            best_y := max a b\n          end;\n        j := !j + 1\n      done;\n      i := !i + 1\n    done;\n    Cons !best_x (Cons !best_y Nil)\nend"
        },
        {
            "description": "Idea 8: Use tail recursive function that iterates through the list and compares each element with next one, assuming sorted list first.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.SortedInt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec tail_aux (l : list int) (idx : int) (len : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { idx < len }\n    variant { len - idx }\n    if idx = len - 1 then\n      best_pair\n    else\n      let a = nth_my idx l in\n      let b = nth_my (idx + 1) l in\n      let diff = abs (b - a) in\n      let (new_diff, new_pair) =\n        if diff < min_diff then (diff, (min a b, max a b)) else (min_diff, best_pair)\n      in\n      tail_aux l (idx + 1) len new_diff new_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = List.sort Int.compare numbers in\n    let len = length sorted in\n    let first = nth_my 0 sorted in\n    let second = nth_my 1 sorted in\n    let init_diff = abs (second - first) in\n    let (x, y) = tail_aux sorted 0 len init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 9: Use a recursive function that splits list into head and tail, finds closest in tail, then compares head with tail elements to find closest pair.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_closest_in_list (l : list int) : (int * int) =\n    match l with\n    | Cons x Nil -> (x, x)\n    | Cons x xs ->\n      let (a, b) = find_closest_in_list xs in\n      let rec find_closest_with_x (l2 : list int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n        match l2 with\n        | Nil -> best_pair\n        | Cons y ys ->\n          let diff = abs (x - y) in\n          let (new_diff, new_pair) =\n            if diff < min_diff then (diff, (min x y, max x y)) else (min_diff, best_pair)\n          in\n          find_closest_with_x ys new_diff new_pair\n        end\n      in\n      let init_diff = abs (b - a) in\n      let best = find_closest_with_x xs init_diff (a, b) in\n      let best_diff = abs (snd best - fst best) in\n      if best_diff < init_diff then best else (a, b)\n    | Nil -> (0, 0)\n    end\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let (x, y) = find_closest_in_list numbers in\n    Cons x (Cons y Nil)\nend"
        },
        {
            "description": "Idea 10: Use difference list transformation by sorting the list, then recursively compare adjacent pairs to find the closest pair.",
            "implementation": "module HumanEval020\n\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.SortedInt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec diff_pairs (l : list int) (idx : int) (len : int) (min_diff : int) (best_pair : (int * int)) : (int * int) =\n    requires { idx < len }\n    variant { len - idx }\n    if idx = len - 1 then\n      best_pair\n    else\n      let a = nth_my idx l in\n      let b = nth_my (idx + 1) l in\n      let diff = abs (b - a) in\n      let (new_diff, new_pair) =\n        if diff < min_diff then (diff, (min a b, max a b)) else (min_diff, best_pair)\n      in\n      diff_pairs l (idx + 1) len new_diff new_pair\n\n  let find_closest_elements (numbers : list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = List.sort Int.compare numbers in\n    let len = length sorted in\n    let first = nth_my 0 sorted in\n    let second = nth_my 1 sorted in\n    let init_diff = abs (second - first) in\n    let (x, y) = diff_pairs sorted 0 len init_diff (min first second, max first second) in\n    Cons x (Cons y Nil)\nend"
        }
    ]
}