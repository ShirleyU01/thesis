{
    "ideas": [
        {
            "description": "Sort the list, then scan adjacent pairs to find the minimum difference. This uses a for-loop over indices.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Sorted\n  use ref.Ref\n\n  let rec insert_sorted (x: int) (l: list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = sort numbers in\n    let n = length sorted in\n    let ref min_diff = abs (nth 1 sorted - nth 0 sorted) in\n    let ref min_idx = 0 in\n    for i = 1 to n - 2 do\n      let d = abs (nth (i+1) sorted - nth i sorted) in\n      if d < !min_diff then (\n        min_diff := d;\n        min_idx := i\n      )\n    done;\n    Cons (nth !min_idx sorted) (Cons (nth (!min_idx+1) sorted) Nil)\nend"
        },
        {
            "description": "Use two nested loops to examine all pairs, tracking the closest pair. This is a brute-force approach.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use ref.Ref\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let ref min_diff = abs (nth 1 numbers - nth 0 numbers) in\n    let ref idx1 = 0 in\n    let ref idx2 = 1 in\n    for i = 0 to n - 2 do\n      for j = i + 1 to n - 1 do\n        let d = abs (nth i numbers - nth j numbers) in\n        if d < !min_diff then (\n          min_diff := d;\n          idx1 := i;\n          idx2 := j\n        )\n      done\n    done;\n    let a = nth !idx1 numbers in\n    let b = nth !idx2 numbers in\n    if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Recursively scan the list, comparing each element to every other, and tracking the closest pair using recursion.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec closest_in_tail (x: int) (tail: list int) (minv: int) (mina: int) (minb: int) : (int, int, int) =\n    match tail with\n    | Nil -> (minv, mina, minb)\n    | Cons y ys ->\n      let diff = abs (x - y) in\n      if diff < minv then closest_in_tail x ys diff x y else closest_in_tail x ys minv mina minb\n    end\n\n  let rec aux (l: list int) (minv: int) (mina: int) (minb: int) : (int, int, int) =\n    match l with\n    | Nil -> (minv, mina, minb)\n    | Cons x xs ->\n      let (d, a, b) = closest_in_tail x xs minv mina minb in\n      aux xs d a b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (d, a, b) = aux numbers (abs (x - y)) x y in\n      if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Sort the list recursively, then scan recursively for minimum adjacent difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec insert_sorted (x: int) (l: list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let rec scan_adj (l: list int) (minv: int) (mina: int) (minb: int) : (int, int, int) =\n    match l with\n    | Cons x (Cons y xs) ->\n      let d = abs (x - y) in\n      if d < minv then scan_adj (Cons y xs) d x y else scan_adj (Cons y xs) minv mina minb\n    | _ -> (minv, mina, minb)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    match sorted with\n    | Cons x (Cons y xs) ->\n      let (d, a, b) = scan_adj sorted (abs (x - y)) x y in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use an accumulator in a recursive tail function to track the closest pair found so far, comparing all pairs.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec aux (l: list int) (acc_min: int) (acc_a: int) (acc_b: int) : (int, int, int) =\n    match l with\n    | Nil -> (acc_min, acc_a, acc_b)\n    | Cons x xs ->\n      let rec inner (t: list int) (minv: int) (mina: int) (minb: int) : (int, int, int) =\n        match t with\n        | Nil -> (minv, mina, minb)\n        | Cons y ys ->\n          let diff = abs (x - y) in\n          if diff < minv then inner ys diff x y else inner ys minv mina minb\n        end\n      in\n      let (d, a, b) = inner xs acc_min acc_a acc_b in\n      aux xs d a b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (d, a, b) = aux numbers (abs (x - y)) x y in\n      if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a while-loop (via refs) to scan the sorted list for adjacent minimum. No recursion.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use ref.Ref\n\n  let rec insert_sorted (x: int) (l: list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    let n = length sorted in\n    let ref i = 0 in\n    let ref min_diff = abs (nth 1 sorted - nth 0 sorted) in\n    let ref min_idx = 0 in\n    while !i < n - 1 do\n      let d = abs (nth (!i+1) sorted - nth !i sorted) in\n      if d < !min_diff then (\n        min_diff := d;\n        min_idx := !i\n      );\n      i := !i + 1\n    done;\n    Cons (nth !min_idx sorted) (Cons (nth (!min_idx+1) sorted) Nil)\nend"
        },
        {
            "description": "Fold over the list, keeping a running minimum difference and pair using a helper function.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec insert_sorted (x: int) (l: list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let rec fold_adj (l: list int) (minv: int) (mina: int) (minb: int) : (int, int, int) =\n    match l with\n    | Cons x (Cons y xs) ->\n      let d = abs (x - y) in\n      if d < minv then fold_adj (Cons y xs) d x y else fold_adj (Cons y xs) minv mina minb\n    | _ -> (minv, mina, minb)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    match sorted with\n    | Cons x (Cons y xs) ->\n      let (d, a, b) = fold_adj sorted (abs (x - y)) x y in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use pattern matching to destructure the list and scan via explicit index tracking and recursion.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec scan (sorted: list int) (i: int) (n: int) (minv: int) (minidx: int) : int =\n    if i >= n - 1 then minidx else\n      let a = nth i sorted in\n      let b = nth (i+1) sorted in\n      let d = abs (b - a) in\n      if d < minv then scan sorted (i+1) n d i else scan sorted (i+1) n minv minidx\n\n  let rec insert_sorted (x: int) (l: list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    let n = length sorted in\n    let minidx = scan sorted 0 n (abs (nth 1 sorted - nth 0 sorted)) 0 in\n    Cons (nth minidx sorted) (Cons (nth (minidx+1) sorted) Nil)\nend"
        },
        {
            "description": "Enumerate all pairs as a list of tuples, then find the tuple with the minimum difference using a recursive min function.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec pairs (l: list int) : list (int, int) =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let rec make_pairs y ys =\n        match ys with\n        | Nil -> Nil\n        | Cons z zs -> Cons (y, z) (make_pairs y zs)\n        end\n      in\n      append (make_pairs x xs) (pairs xs)\n    end\n\n  let rec min_diff_pair (l: list (int, int)) (best: (int, int)) : (int, int) =\n    match l with\n    | Nil -> best\n    | Cons (x, y) xs ->\n      let (a, b) = best in\n      if abs (x - y) < abs (a - b) then min_diff_pair xs (x, y) else min_diff_pair xs best\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let ps = pairs numbers in\n      let (a, b) = min_diff_pair ps (x, y) in\n      if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Map differences between all possible pairs to a list, then find minimum difference; returns the associated pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  let rec all_pairs (l: list int) : list (int, int) =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let rec make_pairs y ys =\n        match ys with\n        | Nil -> Nil\n        | Cons z zs -> Cons (y, z) (make_pairs y zs)\n        end\n      in\n      append (make_pairs x xs) (all_pairs xs)\n    end\n\n  let rec min_pair (l: list (int, int)) (best: (int, int)) : (int, int) =\n    match l with\n    | Nil -> best\n    | Cons (x, y) xs ->\n      let (a, b) = best in\n      if abs (x - y) < abs (a - b) then min_pair xs (x, y) else min_pair xs best\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let ps = all_pairs numbers in\n      let (a, b) = min_pair ps (x, y) in\n      if a <= b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\n    | _ -> Nil\n    end\nend"
        }
    ]
}