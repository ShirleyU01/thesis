{
    "ideas": [
        {
            "description": "Recursive implementation using pattern matching on two lists. At each step, take the heads, compute the absolute difference, and recurse on the tails. If both lists are empty, return Nil.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  use list.Length\n  let rec compare (l1: list int) (l2: list int) : list int =\n    match l1, l2 with\n    | Nil, Nil -> Nil\n    | Cons x xs, Cons y ys -> Cons (abs (x - y)) (compare xs ys)\n    | _, _ -> Nil (* Optionally, handle unequal length by truncating *)\n    end\nend"
        },
        {
            "description": "Imperative implementation using a for-loop over indices. Use nth to access elements, compute differences, and build the result list by appending at each step.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let compare (l1: list int) (l2: list int) : list int =\n    let n = length l1 in\n    let ref res = Nil in\n    for i = n - 1 downto 0 do\n      res <- Cons (abs (nth i l1 - nth i l2)) res\n    done ;\n    res\nend"
        },
        {
            "description": "Recursive implementation using an accumulator in reverse order, then reverse the result at the end to maintain order.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  use list.Length\n  let rec compare_acc (l1: list int) (l2: list int) (acc: list int) : list int =\n    match l1, l2 with\n    | Nil, Nil -> acc\n    | Cons x xs, Cons y ys -> compare_acc xs ys (Cons (abs (x - y)) acc)\n    | _, _ -> acc\n    end\n  let compare (l1: list int) (l2: list int) : list int =\n    reverse (compare_acc l1 l2 Nil)\nend"
        },
        {
            "description": "Implementation using a while-loop with explicit indices and a mutable result list, similar to an array approach. Append to result at each step.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let compare (l1: list int) (l2: list int) : list int =\n    let n = length l1 in\n    let ref i = 0 in\n    let ref res = Nil in\n    while i < n do\n      res <- Cons (abs (nth i l1 - nth i l2)) res ;\n      i <- i + 1\n    done ;\n    reverse res\nend"
        },
        {
            "description": "Implementation using a helper function that zips two lists with a function, similar to zipWith in functional languages. The function here is absolute difference.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  let rec zipwith (f: int -> int -> int) (l1: list int) (l2: list int) : list int =\n    match l1, l2 with\n    | Cons x xs, Cons y ys -> Cons (f x y) (zipwith f xs ys)\n    | _, _ -> Nil\n    end\n  let compare (l1: list int) (l2: list int) : list int =\n    zipwith (\\x y. abs (x - y)) l1 l2\nend"
        },
        {
            "description": "Implementation using a recursive helper that carries the current index, accessing elements by index (nth) instead of pattern matching.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec compare_idx (l1: list int) (l2: list int) (i: int) (n: int) : list int =\n    if i >= n then Nil else\n      let x = nth i l1 in\n      let y = nth i l2 in\n      Cons (abs (x - y)) (compare_idx l1 l2 (i + 1) n)\n  let compare (l1: list int) (l2: list int) : list int =\n    let n = length l1 in\n    compare_idx l1 l2 0 n\nend"
        },
        {
            "description": "Implementation by first pairing (zipping) the lists into a list of tuples, then mapping the absolute difference function over the pairs.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  type pair = (int, int)\n  let rec zip (l1: list int) (l2: list int) : list pair =\n    match l1, l2 with\n    | Cons x xs, Cons y ys -> Cons ((x, y)) (zip xs ys)\n    | _, _ -> Nil\n    end\n  let rec map_abs (lp: list pair) : list int =\n    match lp with\n    | Nil -> Nil\n    | Cons (p, ps) -> let (a, b) = p in Cons (abs (a - b)) (map_abs ps)\n    end\n  let compare (l1: list int) (l2: list int) : list int =\n    map_abs (zip l1 l2)\nend"
        },
        {
            "description": "Implementation that stops comparison as soon as the lists have different lengths, returning results only up to the shortest length (safe variant).",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  let rec compare (l1: list int) (l2: list int) : list int =\n    match l1, l2 with\n    | Cons x xs, Cons y ys -> Cons (abs (x - y)) (compare xs ys)\n    | _, _ -> Nil (* stops when either is Nil *)\n    end\nend"
        },
        {
            "description": "Implementation using a higher-order map2 function, which applies a given function to each pair of elements from the two lists.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  let rec map2 (f: int -> int -> int) (l1: list int) (l2: list int) : list int =\n    match l1, l2 with\n    | Cons x xs, Cons y ys -> Cons (f x y) (map2 f xs ys)\n    | _, _ -> Nil\n    end\n  let compare (l1: list int) (l2: list int) : list int =\n    map2 (\\x y. abs (x - y)) l1 l2\nend"
        },
        {
            "description": "Implementation using explicit if-then-else branching for base cases, rather than pattern matching, to illustrate different style.",
            "implementation": "module HumanEval152\n  use int.Int\n  use list.List\n  let rec compare (l1: list int) (l2: list int) : list int =\n    if l1 = Nil || l2 = Nil then Nil else\n      let Cons x xs = l1 in\n      let Cons y ys = l2 in\n      Cons (abs (x - y)) (compare xs ys)\nend"
        }
    ]
}