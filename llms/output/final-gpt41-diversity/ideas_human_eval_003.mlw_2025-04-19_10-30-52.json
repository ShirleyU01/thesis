{
    "ideas": [
        {
            "description": "Iterative approach using a for-loop over the list indices, maintaining a running balance and returning True if the balance drops below zero at any point.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref balance = 0 in\n    let ref found = False in\n    for i = 0 to n - 1 do\n      balance <- balance + nth i operations;\n      if balance < 0 then found <- True\n    done;\n    found\nend"
        },
        {
            "description": "Iterative approach using a while-loop over the list, updating the balance and checking if it ever drops below zero.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref i = 0 in\n    let ref balance = 0 in\n    let ref found = False in\n    while i < n do\n      balance <- balance + nth i operations;\n      if balance < 0 then found <- True;\n      i <- i + 1\n    done;\n    found\nend"
        },
        {
            "description": "Recursive approach using pattern matching, where the current balance is passed as an accumulator. Returns True if the balance goes below zero.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let rec below_zero_aux (operations: list int) (balance: int) : bool =\n    match operations with\n    | Nil -> False\n    | Cons x xs ->\n        let bal = balance + x in\n        if bal < 0 then True else below_zero_aux xs bal\n    end\n  let below_zero (operations: list int) : bool =\n    below_zero_aux operations 0\nend"
        },
        {
            "description": "Recursive approach using pattern matching, but returns immediately as soon as a negative balance is found (short-circuit recursion).",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let rec below_zero (operations: list int) : bool =\n    let rec aux (ops: list int) (bal: int) : bool =\n      match ops with\n      | Nil -> False\n      | Cons x xs ->\n          if bal + x < 0 then True else aux xs (bal + x)\n      end\n    in aux operations 0\nend"
        },
        {
            "description": "Fold-left style recursion: fold over the list, maintaining a pair (balance, result) to store if negative balance is ever encountered.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let rec fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (l: list 'b) : 'a =\n    match l with\n    | Nil -> acc\n    | Cons x xs -> fold_left f (f acc x) xs\n    end\n  let below_zero (operations: list int) : bool =\n    let step (pair: (int, bool)) (x: int) : (int, bool) =\n      let (bal, res) = pair in\n      if res then (bal + x, True) else (bal + x, bal + x < 0)\n    in\n    let (_, found) = fold_left step (0, False) operations in\n    found\nend"
        },
        {
            "description": "Recursive approach, building the list of partial sums (running totals) first, then checking if any of them is negative.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let rec scanl (f: int -> int -> int) (acc: int) (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> let next = f acc x in Cons next (scanl f next xs)\n    end\n  let rec exists_negative (l: list int) : bool =\n    match l with\n    | Nil -> False\n    | Cons x xs -> if x < 0 then True else exists_negative xs\n    end\n  let below_zero (operations: list int) : bool =\n    let partials = scanl (+) 0 operations in\n    exists_negative partials\nend"
        },
        {
            "description": "Recursive approach using exception-like early exit: wrap the recursion in an option type and return immediately when negative balance is found.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  type option_bool = None | Some bool\n  let rec below_zero_aux (l: list int) (bal: int) : option_bool =\n    match l with\n    | Nil -> Some False\n    | Cons x xs ->\n        let b = bal + x in\n        if b < 0 then Some True else below_zero_aux xs b\n    end\n  let below_zero (operations: list int) : bool =\n    match below_zero_aux operations 0 with\n    | Some res -> res\n    | None -> False\n    end\nend"
        },
        {
            "description": "Using a mutable reference to short-circuit computation in a for-loop, breaking the loop as soon as a negative balance is encountered.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref balance = 0 in\n    let ref found = False in\n    let ref i = 0 in\n    while i < n && not found do\n      balance <- balance + nth i operations;\n      if balance < 0 then found <- True;\n      i <- i + 1\n    done;\n    found\nend"
        },
        {
            "description": "Functional approach using a helper function to generate all partial balance values and then checking if any is negative with a dedicated exists function.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let rec balances (l: list int) (acc: int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> let b = acc + x in Cons b (balances xs b)\n    end\n  let rec exists_negative (l: list int) : bool =\n    match l with\n    | Nil -> False\n    | Cons x xs -> if x < 0 then True else exists_negative xs\n    end\n  let below_zero (operations: list int) : bool =\n    exists_negative (balances operations 0)\nend"
        },
        {
            "description": "Tail-recursive approach with explicit accumulator and early return, designed to be efficient and avoid stack overflow for large lists.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  let below_zero (operations: list int) : bool =\n    let rec aux (ops: list int) (bal: int) : bool =\n      match ops with\n      | Nil -> False\n      | Cons x xs ->\n          let b = bal + x in\n          if b < 0 then True else aux xs b\n      end\n    in aux operations 0\nend"
        }
    ]
}