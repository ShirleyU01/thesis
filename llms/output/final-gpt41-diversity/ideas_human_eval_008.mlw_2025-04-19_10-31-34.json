{
    "ideas": [
        {
            "description": "Recursive pattern matching: Compute sum and product in a single pass using recursion and pattern matching.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n\n  let rec sum_product (l : list int) : list int =\n    match l with\n    | Nil -> Cons 0 (Cons 1 Nil)\n    | Cons x xs ->\n      let res = sum_product xs in\n      match res with\n      | Cons s (Cons p Nil) -> Cons (x + s) (Cons (x * p) Nil)\n      | _ -> res (* should not occur *)\n      end\n    end\nend"
        },
        {
            "description": "First compute sum, then product in separate recursive helper functions, combine results at the end.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n\n  let rec list_sum (l : list int) : int =\n    match l with\n    | Nil -> 0\n    | Cons x xs -> x + list_sum xs\n    end\n\n  let rec list_prod (l : list int) : int =\n    match l with\n    | Nil -> 1\n    | Cons x xs -> x * list_prod xs\n    end\n\n  let sum_product (l : list int) : list int =\n    Cons (list_sum l) (Cons (list_prod l) Nil)\nend"
        },
        {
            "description": "Iterative approach using references and a for loop over the list's indices.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let sum_product (l : list int) : list int =\n    let n = length l in\n    let ref s = 0 in\n    let ref p = 1 in\n    for i = 0 to n-1 do\n      s <- s + nth i l;\n      p <- p * nth i l\n    done;\n    Cons s (Cons p Nil)\nend"
        },
        {
            "description": "While-loop approach using explicit index and accumulator variables.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let sum_product (l : list int) : list int =\n    let n = length l in\n    let ref i = 0 in\n    let ref s = 0 in\n    let ref p = 1 in\n    while i < n do\n      s <- s + nth i l;\n      p <- p * nth i l;\n      i <- i + 1\n    done;\n    Cons s (Cons p Nil)\nend"
        },
        {
            "description": "Single recursive function with two accumulators (tail-recursive style) for sum and product.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  let rec sum_product_acc (l : list int) (s : int) (p : int) : list int =\n    match l with\n    | Nil -> Cons s (Cons p Nil)\n    | Cons x xs -> sum_product_acc xs (s + x) (p * x)\n    end\n  let sum_product (l : list int) : list int =\n    sum_product_acc l 0 1\nend"
        },
        {
            "description": "Map-reduce style: define a fold_left to accumulate sum and product in a tuple, then convert to list at end.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  let rec fold_left_pair (f: (int, int) -> int -> (int, int)) (acc: (int, int)) (l: list int) : (int, int) =\n    match l with\n    | Nil -> acc\n    | Cons x xs -> fold_left_pair f (f acc x) xs\n    end\n  let step ((s, p): (int, int)) (x: int) : (int, int) = (s + x, p * x)\n  let sum_product (l : list int) : list int =\n    let (s, p) = fold_left_pair step (0, 1) l in\n    Cons s (Cons p Nil)\nend"
        },
        {
            "description": "Explicit handling of empty/non-empty with if-then-else before recursive call.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n\n  let sum_product (l : list int) : list int =\n    if l = Nil then Cons 0 (Cons 1 Nil)\n    else\n      let Cons s (Cons p Nil) = sum_product (match l with Cons _ xs -> xs | Nil -> Nil end) in\n      match l with Cons x _ -> Cons (x + s) (Cons (x * p) Nil) | Nil -> Cons s (Cons p Nil) end\nend"
        },
        {
            "description": "Directly traverse the list and construct the output in reverse, then reverse at the end (demonstrating list reversal idiom).",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  let rec traverse (l: list int) (s: int) (p: int) : (int, int) =\n    match l with\n    | Nil -> (s, p)\n    | Cons x xs -> traverse xs (s + x) (p * x)\n    end\n  let sum_product (l : list int) : list int =\n    let (s, p) = traverse l 0 1 in\n    Cons s (Cons p Nil)\nend"
        },
        {
            "description": "Recursive approach, but returning a tuple (pair) and only converting to list at the end.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  type int_pair = (int, int)\n  let rec sum_product_pair (l: list int) : int_pair =\n    match l with\n    | Nil -> (0, 1)\n    | Cons x xs -> let (s, p) = sum_product_pair xs in (x + s, x * p)\n    end\n  let sum_product (l: list int) : list int =\n    let (s, p) = sum_product_pair l in Cons s (Cons p Nil)\nend"
        },
        {
            "description": "Use a combinator: zip the list with itself, fold over the zipped pairs with a reducer for sum and product.",
            "implementation": "module HumanEval008\n  use int.Int\n  use list.List\n  let rec fold_sum_prod (l: list int) (acc_s: int) (acc_p: int) : (int, int) =\n    match l with\n    | Nil -> (acc_s, acc_p)\n    | Cons x xs -> fold_sum_prod xs (acc_s + x) (acc_p * x)\n    end\n  let sum_product (l: list int) : list int =\n    let (s, p) = fold_sum_prod l 0 1 in\n    Cons s (Cons p Nil)\nend"
        }
    ]
}