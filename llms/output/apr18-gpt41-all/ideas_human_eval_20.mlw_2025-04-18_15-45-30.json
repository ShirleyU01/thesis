{
    "ideas": [
        {
            "description": "Iterative approach using two nested for-loops over indices, updating the minimum difference and selected pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref a = nth_my 0 numbers in\n    let ref b = nth_my 1 numbers in\n    for i = 0 to n-2 do\n      for j = i+1 to n-1 do\n        let xi = nth_my i numbers in\n        let xj = nth_my j numbers in\n        let d = abs (xi - xj) in\n        if d < min_diff then (\n          min_diff <- d;\n          if xi < xj then (a <- xi; b <- xj) else (a <- xj; b <- xi)\n        ) else if d = min_diff then (\n          let ta = min xi xj in\n          let tb = max xi xj in\n          if ta < a || (ta = a && tb < b) then (a <- ta; b <- tb)\n        )\n      done\n    done;\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Recursive approach to generate all pairs and select the pair with the minimum difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec all_pairs (l:list int) : list (int,int) =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> let rec pairs_with_x yys =\n        match yys with\n        | Nil -> Nil\n        | Cons y ys -> Cons (x,y) (pairs_with_x ys)\n        end in\n      let rest = all_pairs xs in\n      let with_x = pairs_with_x xs in\n      match with_x with\n      | Nil -> rest\n      | _ -> with_x ++ rest\n      end\n    end\n\n  let rec min_diff_pair (p:list (int,int)) (best:(int,int)) (best_diff:int) : (int,int) =\n    match p with\n    | Nil -> best\n    | Cons (a,b) ps ->\n      let d = abs (a-b) in\n      let mn = min a b in\n      let mx = max a b in\n      let bst_mn = min (fst best) (snd best) in\n      let bst_mx = max (fst best) (snd best) in\n      if d < best_diff || (d = best_diff && (mn < bst_mn || (mn = bst_mn && mx < bst_mx))) then\n        min_diff_pair ps (a,b) d\n      else\n        min_diff_pair ps best best_diff\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let pairs = all_pairs numbers in\n      let (a,b) = min_diff_pair pairs (x1,x2) (abs (x1-x2)) in\n      let mn = min a b in\n      let mx = max a b in\n      Cons mn (Cons mx Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Sort the list first, then scan adjacent pairs to find the closest two numbers (since closest pair must be adjacent after sorting).",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec insert_sorted (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert_sorted x ys)\n    end\n\n  let rec sort (l:list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (sort xs)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    let rec scan (l:list int) (minv:int) (a:int) (b:int) : (int,int) =\n      match l with\n      | Cons x (Cons y ys) ->\n        let d = abs (x-y) in\n        if d < minv then scan (Cons y ys) d x y else scan (Cons y ys) minv a b\n      | _ -> (a,b)\n      end in\n    match sorted with\n    | Cons x1 (Cons x2 xs) ->\n      let (a,b) = scan (Cons x1 (Cons x2 xs)) (abs (x1-x2)) x1 x2 in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Recursive pattern matching, comparing each head with the rest, maintaining the minimum difference and pair found so far.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec find_min_pair (l:list int) (min_diff:int) (a:int) (b:int) : (int,int) =\n    match l with\n    | Nil -> (a,b)\n    | Cons x xs ->\n      let rec cmp_with_x (yys:list int) (cur_min:int) (cur_a:int) (cur_b:int) =\n        match yys with\n        | Nil -> (cur_min, cur_a, cur_b)\n        | Cons y ys ->\n          let d = abs (x-y) in\n          let mn = min x y in\n          let mx = max x y in\n          let bst_mn = min cur_a cur_b in\n          let bst_mx = max cur_a cur_b in\n          if d < cur_min || (d = cur_min && (mn < bst_mn || (mn = bst_mn && mx < bst_mx))) then\n            cmp_with_x ys d mn mx\n          else\n            cmp_with_x ys cur_min cur_a cur_b\n        end\n      in\n      let (new_min, new_a, new_b) = cmp_with_x xs min_diff a b in\n      find_min_pair xs new_min new_a new_b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let (a,b) = find_min_pair (Cons x1 (Cons x2 xs)) (abs (x1-x2)) x1 x2 in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a helper function to accumulate the minimal pair as you traverse the list recursively.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec find_pair_acc (l:list int) (rest:list int) (minv:int) (a:int) (b:int) : (int,int) =\n    match rest with\n    | Nil -> (\n      match l with\n      | Cons x xs -> find_pair_acc xs xs minv a b\n      | Nil -> (a,b)\n      end)\n    | Cons y ys ->\n      match l with\n      | Cons x _ ->\n        let d = abs (x-y) in\n        let mn = min x y in\n        let mx = max x y in\n        let bst_mn = min a b in\n        let bst_mx = max a b in\n        if d < minv || (d = minv && (mn < bst_mn || (mn = bst_mn && mx < bst_mx))) then\n          find_pair_acc l ys d mn mx\n        else\n          find_pair_acc l ys minv a b\n      | Nil -> (a,b)\n      end\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let (a,b) = find_pair_acc (Cons x1 (Cons x2 xs)) (Cons x2 xs) (abs (x1-x2)) x1 x2 in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Iterative approach using a single index and comparing each element with all elements that follow it.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref a = nth_my 0 numbers in\n    let ref b = nth_my 1 numbers in\n    for i = 0 to n-2 do\n      let xi = nth_my i numbers in\n      for j = i+1 to n-1 do\n        let xj = nth_my j numbers in\n        let d = abs (xi - xj) in\n        let mn = min xi xj in\n        let mx = max xi xj in\n        let bst_mn = min a b in\n        let bst_mx = max a b in\n        if d < min_diff || (d = min_diff && (mn < bst_mn || (mn = bst_mn && mx < bst_mx))) then (\n          min_diff <- d; a <- mn; b <- mx\n        )\n      done\n    done;\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Recursive approach that uses a helper to keep current minimum difference and pair, without explicit nested helpers.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec closest_aux (l:list int) (minv:int) (a:int) (b:int) : (int,int) =\n    match l with\n    | Nil -> (a,b)\n    | Cons x xs ->\n      let rec cmp_rest (ys:list int) (cur_min:int) (cur_a:int) (cur_b:int) =\n        match ys with\n        | Nil -> (cur_min, cur_a, cur_b)\n        | Cons y ys' ->\n          let d = abs (x-y) in\n          let mn = min x y in\n          let mx = max x y in\n          let bst_mn = min cur_a cur_b in\n          let bst_mx = max cur_a cur_b in\n          if d < cur_min || (d = cur_min && (mn < bst_mn || (mn = bst_mn && mx < bst_mx))) then\n            cmp_rest ys' d mn mx\n          else\n            cmp_rest ys' cur_min cur_a cur_b\n        end\n      in\n      let (new_min, new_a, new_b) = cmp_rest xs minv a b in\n      closest_aux xs new_min new_a new_b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let (a,b) = closest_aux (Cons x1 (Cons x2 xs)) (abs (x1-x2)) x1 x2 in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Generate a list of all differences and their associated pairs, then scan for the pair with the minimum difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec all_pairs (l:list int) : list (int,int) =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      let rec with_x (ys:list int) =\n        match ys with\n        | Nil -> Nil\n        | Cons y ys' -> Cons (x,y) (with_x ys')\n        end\n      in\n      (with_x xs) ++ (all_pairs xs)\n    end\n\n  let rec pair_diffs (pairs:list (int,int)) : list (int*int*int) =\n    match pairs with\n    | Nil -> Nil\n    | Cons (a,b) ps -> Cons (abs (a-b), min a b, max a b) (pair_diffs ps)\n    end\n\n  let rec min_triplet (ts:list (int*int*int)) (cur:(int*int*int)) : (int*int*int) =\n    match ts with\n    | Nil -> cur\n    | Cons (d,a,b) ts' ->\n      let (cd,ca,cb) = cur in\n      if d < cd || (d = cd && (a < ca || (a = ca && b < cb))) then\n        min_triplet ts' (d,a,b)\n      else\n        min_triplet ts' cur\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let pairs = all_pairs numbers in\n      let diff_list = pair_diffs pairs in\n      let (d,a,b) = min_triplet diff_list (abs (x1-x2), min x1 x2, max x1 x2) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Recursive approach that always compares first two elements, then recursively checks rest; returns the best pair found.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n\n  let rec min_pair (l:list int) : (int,int,int) =\n    match l with\n    | Cons x (Cons y Nil) -> (abs (x-y), min x y, max x y)\n    | Cons x (Cons y ys) ->\n      let (rest_diff, rest_a, rest_b) = min_pair (Cons y ys) in\n      let d = abs (x-y) in\n      let mn = min x y in\n      let mx = max x y in\n      if d < rest_diff || (d = rest_diff && (mn < rest_a || (mn = rest_a && mx < rest_b))) then\n        (d, mn, mx)\n      else\n        (rest_diff, rest_a, rest_b)\n    | _ -> (0,0,0)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let (d,a,b) = min_pair (Cons x1 (Cons x2 xs)) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Divide-and-conquer: split the list, find closest pair in each half, and compare cross-pairs.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Prefix\n\n  let rec get_last (l:list int) : int =\n    match l with\n    | Cons x Nil -> x\n    | Cons _ xs -> get_last xs\n    | Nil -> 0\n    end\n\n  let rec min_pair (l:list int) : (int,int,int) =\n    let n = length l in\n    if n = 2 then\n      match l with\n      | Cons a (Cons b Nil) -> (abs (a-b), min a b, max a b)\n      | _ -> (0,0,0)\n      end\n    else\n      let h = n div 2 in\n      let left = prefix h l in\n      let right =\n        let rec drop (k:int) (l:list int) : list int =\n          if k = 0 then l else match l with | Nil -> Nil | Cons _ xs -> drop (k-1) xs end in\n        drop h l\n      in\n      let (d1,a1,b1) = min_pair left in\n      let (d2,a2,b2) = min_pair right in\n      let cross_d = abs (get_last left -\n                         match right with | Cons x _ -> x | _ -> get_last left end) in\n      let cross_a = min (get_last left) (match right with | Cons x _ -> x | _ -> get_last left end) in\n      let cross_b = max (get_last left) (match right with | Cons x _ -> x | _ -> get_last left end) in\n      if d1 <= d2 && d1 <= cross_d then (d1,a1,b1)\n      else if d2 <= d1 && d2 <= cross_d then (d2,a2,b2)\n      else (cross_d,cross_a,cross_b)\n  \n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x1 (Cons x2 xs) ->\n      let (d,a,b) = min_pair (Cons x1 (Cons x2 xs)) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        }
    ]
}