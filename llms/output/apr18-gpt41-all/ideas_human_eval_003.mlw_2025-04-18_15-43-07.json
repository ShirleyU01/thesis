{
    "ideas": [
        {
            "description": "Iterative for-loop using index and accumulator variable to track the balance, returns true as soon as balance goes below zero.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref bal = 0 in\n    let ref i = 0 in\n    let ref res = false in\n    while i < n do\n      bal <- bal + nth_my i operations;\n      if bal < 0 then res <- true;\n      i <- i + 1\n    done;\n    res\nend"
        },
        {
            "description": "Recursive pattern-matching: recursively sum the head to an accumulator, and return true as soon as accumulator is negative.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n\n  let rec below_zero_acc (ops: list int) (acc: int) : bool =\n    match ops with\n    | Nil -> false\n    | Cons x xs ->\n        let sum = acc + x in\n        if sum < 0 then true else below_zero_acc xs sum\n    end\n\n  let below_zero (operations: list int) : bool =\n    below_zero_acc operations 0\nend"
        },
        {
            "description": "While-loop on the list using explicit pointer and hd/tl: iterate through the list node by node, updating balance and checking negative.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.HdTlNoOpt\n\n  let below_zero (operations: list int) : bool =\n    let ref bal = 0 in\n    let ref l = operations in\n    let ref found = false in\n    while l <> Nil do\n      bal <- bal + hd l;\n      if bal < 0 then found <- true;\n      l <- tl l\n    done;\n    found\nend"
        },
        {
            "description": "Recursive version, but using a helper that short-circuits and returns true immediately on first negative balance, else continues.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n\n  let rec below_zero_helper (l: list int) (bal: int) : bool =\n    match l with\n    | Nil -> false\n    | Cons x xs ->\n        let bal' = bal + x in\n        if bal' < 0 then true else below_zero_helper xs bal'\n    end\n\n  let below_zero (operations: list int) : bool =\n    below_zero_helper operations 0\nend"
        },
        {
            "description": "Iterative for-loop, but using an early return by breaking from loop via a boolean guard variable.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref bal = 0 in\n    let ref i = 0 in\n    let ref found = false in\n    while i < n && not found do\n      bal <- bal + nth_my i operations;\n      if bal < 0 then found <- true;\n      i <- i + 1\n    done;\n    found\nend"
        },
        {
            "description": "Recursive solution using pattern matching, but accumulates the sum first and only checks at end (inefficient, but valid).",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n\n  let rec prefix_sums (ops: list int) (acc: int) : list int =\n    match ops with\n    | Nil -> Nil\n    | Cons x xs -> Cons (acc + x) (prefix_sums xs (acc + x))\n    end\n\n  let rec any_below_zero (l: list int) : bool =\n    match l with\n    | Nil -> false\n    | Cons x xs -> if x < 0 then true else any_below_zero xs\n    end\n\n  let below_zero (operations: list int) : bool =\n    let sums = prefix_sums operations 0 in\n    any_below_zero sums\nend"
        },
        {
            "description": "Iterative approach with a separate list of running balances (prefix sums), and check if any is below zero at the end.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Append\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref bal = 0 in\n    let ref i = 0 in\n    let ref sums = Nil in\n    while i < n do\n      bal <- bal + nth_my i operations;\n      sums <- Cons bal sums;\n      i <- i + 1\n    done;\n    let rec check_neg (l: list int) : bool =\n      match l with\n      | Nil -> false\n      | Cons x xs -> if x < 0 then true else check_neg xs\n      end\n    in check_neg sums\nend"
        },
        {
            "description": "Recursive version using two mutually recursive helpers: one accumulates sum, the other checks for negative in the list.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n\n  let rec get_prefixes (ops: list int) (acc: int) : list int =\n    match ops with\n    | Nil -> Nil\n    | Cons x xs -> Cons (acc + x) (get_prefixes xs (acc + x))\n    end\n\n  let rec below_zero (operations: list int) : bool =\n    let rec has_neg (l: list int) : bool =\n      match l with\n      | Nil -> false\n      | Cons x xs -> if x < 0 then true else has_neg xs\n      end\n    in\n    let sums = get_prefixes operations 0 in\n    has_neg sums\nend"
        },
        {
            "description": "Purely recursive, no accumulator version: for each prefix, computes sum from start up to that point and checks if negative.",
            "implementation": "module HumanEval003\n  use int.Int\n  use list.List\n\n  let rec sum_prefix (l: list int) : int =\n    match l with\n    | Nil -> 0\n    | Cons x xs -> x + sum_prefix xs\n    end\n\n  let rec below_zero (operations: list int) : bool =\n    match operations with\n    | Nil -> false\n    | Cons _ _ ->\n        let rec check (l: list int) : bool =\n          match l with\n          | Nil -> false\n          | _ -> if sum_prefix l < 0 then true else check (match l with Cons _ xs -> xs | Nil -> Nil end)\n          end\n        in check operations\n    end\nend"
        },
        {
            "description": "Iterative using for-loop and min prefix sum: find minimum running balance, return true if it is negative.",
            "implementation": "module HumanEval003\n  use int.Int\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let below_zero (operations: list int) : bool =\n    let n = length operations in\n    let ref bal = 0 in\n    let ref minbal = 0 in\n    let ref i = 0 in\n    while i < n do\n      bal <- bal + nth_my i operations;\n      minbal <- min minbal bal;\n      i <- i + 1\n    done;\n    minbal < 0\nend"
        }
    ]
}