{
    "ideas": [
        {
            "description": "Euclidean Algorithm, recursive version using mod",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if b = 0 then abs a else greatest_common_divisor b (mod a b)\nend"
        },
        {
            "description": "Iterative Euclidean Algorithm using while-loop with abs",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  use int.Abs\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    while y <> 0 do\n      let tmp = y in\n      y <- mod x y;\n      x <- tmp\n    done;\n    x\nend"
        },
        {
            "description": "Subtraction-based GCD (recursive version, no mod/div)",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 then y\n    else if y = 0 then x\n    else if x > y then greatest_common_divisor (x - y) y\n    else greatest_common_divisor x (y - x)\nend"
        },
        {
            "description": "For-loop over divisors from min(a,b) down to 1",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use int.EuclideanDivision\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    let ref d = 1 in\n    for i = m downto 1 do\n      if mod x i = 0 && mod y i = 0 then d <- i\n    done;\n    d\nend"
        },
        {
            "description": "Iterative subtraction-based GCD using while-loop",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    while x <> 0 && y <> 0 do\n      if x > y then x <- x - y else y <- y - x\n    done;\n    if x = 0 then y else x\nend"
        },
        {
            "description": "Recursive Euclidean Algorithm making b positive in the call",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  use int.Abs\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if b = 0 then abs a\n    else greatest_common_divisor b (mod (abs a) (abs b))\nend"
        },
        {
            "description": "Checking all divisors up to min(a,b) using while-loop",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use int.EuclideanDivision\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    let ref i = 1 in\n    let ref d = 1 in\n    while i <= m do\n      if mod x i = 0 && mod y i = 0 then d <- i;\n      i <- i + 1\n    done;\n    d\nend"
        },
        {
            "description": "Special case handling for zero input, then Euclidean Algorithm",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  use int.Abs\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if a = 0 && b = 0 then 0\n    else if b = 0 then abs a\n    else greatest_common_divisor b (mod a b)\nend"
        },
        {
            "description": "Iterative Euclidean Algorithm, swapping if needed to ensure a >= b",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  use int.Abs\n  use int.MinMax\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    if x < y then let t = x in x <- y; y <- t end;\n    while y <> 0 do\n      let t = y in\n      y <- mod x y;\n      x <- t\n    done;\n    x\nend"
        },
        {
            "description": "Recursive, handles negative numbers explicitly, fallback to abs for result",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if b = 0 then if a < 0 then -a else a\n    else greatest_common_divisor b (mod a b)\nend"
        }
    ]
}