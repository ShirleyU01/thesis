{
    "ideas": [
        {
            "description": "Using recursion and pattern matching to check both increasing and decreasing properties.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then is_increasing (Cons y r) else false\n    end\n  let rec is_decreasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x >= y then is_decreasing (Cons y r) else false\n    end\n  let monotonic (l: list int) : bool =\n    is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Using a single recursive helper function with a direction parameter (1 for increasing, -1 for decreasing), checking both directions.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec check_dir (l: list int) (dir: int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) ->\n        if dir = 1 then if x <= y then check_dir (Cons y r) dir else false\n        else if dir = -1 then if x >= y then check_dir (Cons y r) dir else false\n        else false\n    end\n  let monotonic (l: list int) : bool =\n    check_dir l 1 || check_dir l (-1)\nend"
        },
        {
            "description": "Iterative approach using a for-loop and nth_my to check both increasing and decreasing properties.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n  let monotonic (l: list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let ref inc = true in\n    let ref dec = true in\n    for i = 0 to n - 2 do\n      let x = nth_my i l in\n      let y = nth_my (i + 1) l in\n      if x > y then inc <- false;\n      if x < y then dec <- false;\n    done;\n    inc || dec\nend"
        },
        {
            "description": "Using Why3's sorted and RevSorted modules to directly check monotonicity.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.SortedInt\n  use list.RevSorted\n  let monotonic (l: list int) : bool =\n    sorted l || rev_sorted l\nend"
        },
        {
            "description": "Recursive approach that detects the direction on-the-fly by comparing the first two elements, then recurses accordingly.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec monotonic_helper (l: list int) (direction: int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) ->\n        if direction = 0 then\n          if x < y then monotonic_helper (Cons y r) 1\n          else if x > y then monotonic_helper (Cons y r) (-1)\n          else monotonic_helper (Cons y r) 0\n        else if direction = 1 then\n          if x <= y then monotonic_helper (Cons y r) 1 else false\n        else (* direction = -1 *)\n          if x >= y then monotonic_helper (Cons y r) (-1) else false\n    end\n  let monotonic (l: list int) : bool =\n    monotonic_helper l 0\nend"
        },
        {
            "description": "Using a while-loop and nth_my to check monotonicity in a single pass, detecting direction after first difference.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n  let monotonic (l: list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let ref i = 0 in\n    let ref direction = 0 in\n    let ref res = true in\n    while i < n - 1 && res do\n      let x = nth_my i l in\n      let y = nth_my (i + 1) l in\n      if direction = 0 then\n        if x < y then direction <- 1\n        else if x > y then direction <- -1;\n      else if direction = 1 then\n        if x > y then res <- false;\n      else if direction = -1 then\n        if x < y then res <- false;\n      i <- i + 1\n    done;\n    res\nend"
        },
        {
            "description": "Recursive accumulator approach that carries a 'still_increasing' and 'still_decreasing' boolean through the recursion.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec monotonic_acc (l: list int) (inc: bool) (dec: bool) : bool =\n    match l with\n    | Nil -> inc || dec\n    | Cons _ Nil -> inc || dec\n    | Cons x (Cons y r) ->\n        let inc' = inc && (x <= y) in\n        let dec' = dec && (x >= y) in\n        monotonic_acc (Cons y r) inc' dec'\n    end\n  let monotonic (l: list int) : bool =\n    monotonic_acc l true true\nend"
        },
        {
            "description": "Recursive approach that counts the number of increases and decreases, then checks if one is zero.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec count_inc_dec (l: list int) (inc: int) (dec: int) : (int, int) =\n    match l with\n    | Nil -> (inc, dec)\n    | Cons _ Nil -> (inc, dec)\n    | Cons x (Cons y r) ->\n        if x < y then count_inc_dec (Cons y r) (inc + 1) dec\n        else if x > y then count_inc_dec (Cons y r) inc (dec + 1)\n        else count_inc_dec (Cons y r) inc dec\n    end\n  let monotonic (l: list int) : bool =\n    let (inc, dec) = count_inc_dec l 0 0 in\n    inc = 0 || dec = 0\nend"
        },
        {
            "description": "Using recursion with an option type to determine direction at the first step and check accordingly.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  type direction = Inc | Dec | Eq\n  let rec check_mono (l: list int) (d: direction) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) ->\n        match d with\n        | Eq ->\n            if x < y then check_mono (Cons y r) Inc\n            else if x > y then check_mono (Cons y r) Dec\n            else check_mono (Cons y r) Eq\n        | Inc -> if x <= y then check_mono (Cons y r) Inc else false\n        | Dec -> if x >= y then check_mono (Cons y r) Dec else false\n        end\n    end\n  let monotonic (l: list int) : bool =\n    check_mono l Eq\nend"
        },
        {
            "description": "Recursive approach that checks for monotonicity by comparing the sign of differences between consecutive elements.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec get_sign (x: int) : int =\n    if x > 0 then 1 else if x < 0 then -1 else 0\n  let rec check_sign (l: list int) (expected: int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) ->\n        let s = get_sign (y - x) in\n        if s = 0 || s = expected then check_sign (Cons y r) expected else false\n    end\n  let rec find_first_nonzero (l: list int) : int =\n    match l with\n    | Nil -> 0\n    | Cons _ Nil -> 0\n    | Cons x (Cons y r) ->\n        let s = get_sign (y - x) in\n        if s = 0 then find_first_nonzero (Cons y r) else s\n    end\n  let monotonic (l: list int) : bool =\n    let s = find_first_nonzero l in\n    if s = 0 then true else check_sign l s\nend"
        }
    ]
}