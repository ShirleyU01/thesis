{
    "ideas": [
        {
            "description": "Using pattern matching and recursion to filter positive numbers from the list.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use int.Int\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if x > 0 then Cons x (get_positive xs) else get_positive xs\n    end\n\nend"
        },
        {
            "description": "Using accumulator within recursion to gather positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use int.Int\n\n  let rec get_positive_acc (l : list int) (acc : list int) : list int =\n    match l with\n    | Nil -> acc\n    | Cons x xs -> if x > 0 then get_positive_acc xs (Cons x acc) else get_positive_acc xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    reverse (get_positive_acc l Nil)\n\nend"
        },
        {
            "description": "Using a higher-order function, fold_left, to accumulate positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.FoldLeft\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    fold_left (fun acc x -> if x > 0 then Cons x acc else acc) Nil l\n\nend"
        },
        {
            "description": "Using a while-loop to iterate through the list and construct a new list of positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Length\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref i = 0 in\n    let ref result = Nil in\n    while i < n do\n      let x = nth i l in\n      if x > 0 then result <- Cons x result;\n      i <- i + 1\n    done;\n    reverse result\n\nend"
        },
        {
            "description": "Using for-loop to iterate over the list and append positive numbers to a new list.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Length\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref result = Nil in\n    for i = 0 to n - 1 do\n      let x = nth i l in\n      if x > 0 then result <- Cons x result\n    done;\n    reverse result\n\nend"
        },
        {
            "description": "Using map to transform the list and filter out non-positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Map\n  use list.Filter\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    filter (fun x -> x > 0) l\n\nend"
        },
        {
            "description": "Using a combination of map and filter to achieve the desired result.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Map\n  use list.Filter\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    map (fun x -> if x > 0 then Some x else None) l\n    |> filter (fun x -> x <> None)\n    |> map (fun x -> match x with Some y -> y | None -> 0)\n\nend"
        },
        {
            "description": "Utilizing a reverse approach where we first reverse the list, filter, and then reverse again.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Reverse\n  use list.Filter\n  use int.Int\n\n  let get_positive (l : list int) : list int =\n    reverse (filter (fun x -> x > 0) (reverse l))\n\nend"
        },
        {
            "description": "Using a recursive helper function that maintains a positive list as it traverses.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use int.Int\n\n  let rec helper (l : list int) (pos : list int) : list int =\n    match l with\n    | Nil -> pos\n    | Cons x xs -> if x > 0 then helper xs (Cons x pos) else helper xs pos\n    end\n\n  let get_positive (l : list int) : list int =\n    reverse (helper l Nil)\n\nend"
        },
        {
            "description": "Using pattern matching with an explicit accumulator in a tail-recursive function.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use int.Int\n\n  let rec get_positive_aux (l : list int) (acc : list int) : list int =\n    match l with\n    | Nil -> reverse acc\n    | Cons x xs -> if x > 0 then get_positive_aux xs (Cons x acc) else get_positive_aux xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    get_positive_aux l Nil\n\nend"
        }
    ]
}