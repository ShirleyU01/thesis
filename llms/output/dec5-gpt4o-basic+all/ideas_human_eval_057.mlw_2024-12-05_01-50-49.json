{
    "ideas": [
        {
            "description": "Using pattern matching with two recursive helper functions to check both increasing and decreasing order.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.Length\n\nlet rec is_increasing (l : list int) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) -> if x <= y then is_increasing (Cons y ys) else false\n  end\n\nlet rec is_decreasing (l : list int) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) -> if x >= y then is_decreasing (Cons y ys) else false\n  end\n\nlet monotonic (l : list int) : bool =\n  is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Using a single recursive function with an accumulator to track the current direction of monotonicity.",
            "implementation": "module HumanEval057\nuse list.List\nuse int.Int\n\nlet rec monotonic_aux (l : list int) (inc : bool) (dec : bool) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) ->\n      if x < y then monotonic_aux (Cons y ys) true dec\n      else if x > y then monotonic_aux (Cons y ys) inc true\n      else monotonic_aux (Cons y ys) inc dec\n  end\n\nlet monotonic (l : list int) : bool =\n  monotonic_aux l false false\nend"
        },
        {
            "description": "Using a while-loop to iterate through the list and flags to determine monotonicity.",
            "implementation": "module HumanEval057\nuse list.List\nuse int.Int\nuse list.Length\nuse list.NthNoOpt\n\nlet rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end \n\nlet monotonic (l : list int) : bool =\n  if length l <= 1 then true\n  else\n    let ref i = 0 in\n    let ref inc = true in\n    let ref dec = true in\n    let n = length l in\n    while i < n - 1 do\n      let x = nth_my i l in\n      let y = nth_my (i + 1) l in\n      if x < y then dec <- false\n      else if x > y then inc <- false;\n      i <- i + 1\n    done;\n    inc || dec\nend"
        },
        {
            "description": "Using fold_left to accumulate the monotonicity status while iterating over the list.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.FoldLeft\nuse int.Int\n\nlet monotonic (l : list int) : bool =\n  let (inc, dec) = fold_left (fun (inc, dec) x y ->\n    (inc && x <= y, dec && x >= y)) (true, true) l in\n  inc || dec\nend"
        },
        {
            "description": "Using for_all and a helper function to determine if the list is either entirely non-decreasing or non-increasing.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.Quant\nuse int.Int\n\nlet rec non_decreasing (l : list int) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) -> x <= y && non_decreasing (Cons y ys)\n  end\n\nlet rec non_increasing (l : list int) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) -> x >= y && non_increasing (Cons y ys)\n  end\n\nlet monotonic (l : list int) : bool =\n  non_decreasing l || non_increasing l\nend"
        },
        {
            "description": "Using pattern matching and a tuple to track the last two elements to check monotonicity.",
            "implementation": "module HumanEval057\nuse list.List\nuse int.Int\n\nlet rec monotonic_aux (l : list int) (prev : int) (inc : bool) (dec : bool) : bool =\n  match l with\n  | Nil -> true\n  | Cons x xs ->\n      if prev < x then monotonic_aux xs x true dec\n      else if prev > x then monotonic_aux xs x inc true\n      else monotonic_aux xs x inc dec\n  end\n\nlet monotonic (l : list int) : bool =\n  match l with\n  | Nil -> true\n  | Cons x xs -> monotonic_aux xs x false false\n  end\nend"
        },
        {
            "description": "Using map to transform the list into a list of differences, then checking if all are non-negative or non-positive.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.Map\nuse int.Int\n\nlet diff (x : int) (y : int) : int = y - x\n\nlet rec diff_list (l : list int) : list int =\n  match l with\n  | Nil -> Nil\n  | Cons x Nil -> Nil\n  | Cons x (Cons y ys) -> Cons (diff x y) (diff_list (Cons y ys))\n  end\n\nlet monotonic (l : list int) : bool =\n  let dl = diff_list l in\n  for_all (fun x -> x >= 0) dl || for_all (fun x -> x <= 0) dl\nend"
        },
        {
            "description": "Using two separate functions to check if the list is sorted in either increasing or decreasing order.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.SortedInt\nuse list.RevSorted\n\nlet monotonic (l : list int) : bool =\n  sorted l || revsorted l\nend"
        },
        {
            "description": "Using an iterative approach with a ref variable to track changes in direction, ensuring only one direction of change.",
            "implementation": "module HumanEval057\nuse list.List\nuse int.Int\nuse list.Length\nuse list.NthNoOpt\n\nlet rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end \n\nlet monotonic (l : list int) : bool =\n  if length l <= 1 then true\n  else\n    let ref i = 0 in\n    let ref direction = 0 in\n    let n = length l in\n    while i < n - 1 do\n      let x = nth_my i l in\n      let y = nth_my (i + 1) l in\n      if x < y then\n        (if direction = -1 then direction <- 2 else direction <- 1)\n      else if x > y then\n        (if direction = 1 then direction <- 2 else direction <- -1);\n      if direction = 2 then i <- n else i <- i + 1\n    done;\n    direction <> 2\nend"
        },
        {
            "description": "Using a combination of head and tail functions to recursively check the list for monotonicity.",
            "implementation": "module HumanEval057\nuse list.List\nuse list.HdTlNoOpt\nuse int.Int\n\nlet rec is_monotonic (l : list int) (inc : bool) (dec : bool) : bool =\n  match l with\n  | Nil -> true\n  | Cons x Nil -> true\n  | Cons x (Cons y ys) ->\n      if x < y then is_monotonic (Cons y ys) true dec\n      else if x > y then is_monotonic (Cons y ys) inc true\n      else is_monotonic (Cons y ys) inc dec\n  end\n\nlet monotonic (l : list int) : bool =\n  is_monotonic l false false\nend"
        }
    ]
}