{
    "ideas": [
        {
            "description": "Use a recursive function to filter positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n\n  let rec get_positive (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons h t -> if h > 0 then Cons h (get_positive t) else get_positive t\n\nend"
        },
        {
            "description": "Iterate through the list using a while loop and collect positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Length\n\n  let get_positive (l: list int) : list int =\n    let rec aux acc l =\n      match l with\n      | Nil -> List.rev acc\n      | Cons h t -> aux (if h > 0 then Cons h acc else acc) t\n    in aux Nil l\n\nend"
        },
        {
            "description": "Use a higher-order function to filter the list.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Filter\n\n  let is_positive (x: int) : bool = x > 0\n\n  let get_positive (l: list int) : list int =\n    filter is_positive l\n\nend"
        },
        {
            "description": "Use pattern matching and list comprehensions.",
            "implementation": "module HumanEval030\n\n  use list.List\n\n  let rec get_positive (l: list int) : list int =\n    let rec aux l acc =\n      match l with\n      | Nil -> List.rev acc\n      | Cons h t -> aux t (if h > 0 then Cons h acc else acc)\n    in aux l Nil\n\nend"
        },
        {
            "description": "Implement using fold operation to accumulate positive numbers.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Fold\n\n  let get_positive (l: list int) : list int =\n    fold (fun acc x -> if x > 0 then Cons x acc else acc) Nil (rev l)\n\nend"
        },
        {
            "description": "Use a combination of map and filter functions.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Map\n  use list.Filter\n\n  let map_positive (x: int) : option int = if x > 0 then Some x else None\n\n  let get_positive (l: list int) : list int =\n    flatten_option (map map_positive l)\n\nend"
        },
        {
            "description": "Filter using a custom filter function.",
            "implementation": "module HumanEval030\n\n  use list.List\n\n  let rec custom_filter (f: int -> bool) (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons h t -> if f h then Cons h (custom_filter f t) else custom_filter f t\n\n  let get_positive (l: list int) : list int =\n    custom_filter (fun x -> x > 0) l\n\nend"
        },
        {
            "description": "Use an accumulator-based recursive solution.",
            "implementation": "module HumanEval030\n\n  use list.List\n\n  let rec get_positive_aux (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> List.rev acc\n    | Cons h t -> get_positive_aux t (if h > 0 then Cons h acc else acc)\n\n  let get_positive (l: list int) : list int =\n    get_positive_aux l Nil\n\nend"
        },
        {
            "description": "Utilize a tail-recursive function with an accumulator.",
            "implementation": "module HumanEval030\n\n  use list.List\n\n  let rec get_positive_tr_aux (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> List.rev acc\n    | Cons h t -> if h > 0 then get_positive_tr_aux t (Cons h acc) else get_positive_tr_aux t acc\n\n  let get_positive (l: list int) : list int =\n    get_positive_tr_aux l Nil\n\nend"
        },
        {
            "description": "Use a filter with an inline predicate function.",
            "implementation": "module HumanEval030\n\n  use list.List\n  use list.Filter\n\n  let get_positive (l: list int) : list int =\n    filter (fun x -> x > 0) l\n\nend"
        }
    ]
}