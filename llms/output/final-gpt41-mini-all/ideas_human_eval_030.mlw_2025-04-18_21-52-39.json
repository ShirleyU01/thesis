{
    "ideas": [
        {
            "description": "Recursive filtering with pattern matching: traverse the list recursively, at each step check if head is positive, include it if yes, otherwise skip.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if x > 0 then Cons x (get_positive xs) else get_positive xs\n    end\nend"
        },
        {
            "description": "Recursive filtering with accumulator: use a helper function with an accumulator to collect positive numbers in reverse order, then reverse the result at the end.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n  use list.Reverse\n\n  let rec aux (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> acc\n    | Cons x xs -> if x > 0 then aux xs (Cons x acc) else aux xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    reverse (aux l Nil)\n\nend"
        },
        {
            "description": "Recursive filtering with branching and explicit if-then-else: recursively check head and decide inclusion with explicit if-then-else instead of pattern matching conditions.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> begin\n        if x > 0 then Cons x (get_positive xs) else get_positive xs\n      end\n    end\n\nend"
        },
        {
            "description": "Recursive filtering using nested match expressions: decompose the list twice using nested matches, process head and tail with nested pattern matching.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> match x > 0 with\n        | True -> Cons x (get_positive xs)\n        | False -> get_positive xs\n      end\n    end\n\nend"
        },
        {
            "description": "Iterative approach with refs and while loop: use mutable references to iterate through the list indices, checking each element and building result list with Cons, accumulating in reverse order, then reverse before returning.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Reverse\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n               n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref i = 0 in\n    let ref acc = Nil in\n    while !i < n do\n      let x = nth_my !i l in\n      if x > 0 then acc <- Cons x !acc;\n      i <- !i + 1\n    done;\n    reverse !acc\n\nend"
        },
        {
            "description": "Tail-recursion with accumulator and explicit match: use a tail-recursive helper function with accumulator and pattern matching to build the list of positives in reverse, then reverse at the end.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n  use list.Reverse\n\n  let rec aux (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> acc\n    | Cons x xs ->\n      if x > 0 then aux xs (Cons x acc) else aux xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    reverse (aux l Nil)\n\nend"
        },
        {
            "description": "Filtering by reconstructing list with a conditional append: use concatenation operator ++ to append either single-element list or empty list recursively.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n  use list.Append\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      if x > 0 then Cons x Nil ++ get_positive xs else get_positive xs\n    end\n\nend"
        },
        {
            "description": "Filter using a nested helper function with pattern matching and if condition to separate positive and non-positive elements, then combine the results through recursion.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n      if x > 0 then\n        Cons x (get_positive xs)\n      else\n        get_positive xs\n    end\n\nend"
        },
        {
            "description": "Recursive filtering with explicit variant annotation and ensures clause for correctness (though no proof included), for demonstration of formal style.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    variant { l }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if x > 0 then Cons x (get_positive xs) else get_positive xs\n    end\n\nend"
        },
        {
            "description": "Recursive filter using match with boolean guard and explicit begin-end block for condition, emphasizing syntax variant.",
            "implementation": "module HumanEval030\n\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> begin\n        if x > 0 then Cons x (get_positive xs) else get_positive xs\n      end\n    end\n\nend"
        }
    ]
}