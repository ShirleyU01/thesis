{
    "ideas": [
        {
            "description": "Classic recursive implementation: traverse the list recursively, cons positive elements, and skip non-positive.",
            "implementation": "module HumanEval030\n  use import list.List\n  let rec get_positive (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if x > 0 then Cons x (get_positive xs) else get_positive xs\n    end\nend"
        },
        {
            "description": "Tail-recursive implementation using an accumulator to build the result in reverse, then reverse the accumulator at the end.",
            "implementation": "module HumanEval030\n  use import list.List\n  use import list.Append\n  let rec get_positive_acc (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> acc\n    | Cons x xs ->\n        if x > 0 then get_positive_acc xs (Cons x acc)\n        else get_positive_acc xs acc\n    end\n  let get_positive (l: list int) : list int =\n    reverse (get_positive_acc l Nil)\nend"
        },
        {
            "description": "Implementation using a helper function to append positives to the end (not efficient, but different).",
            "implementation": "module HumanEval030\n  use import list.List\n  use import list.Append\n  let rec get_positive (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n        let rest = get_positive xs in\n        if x > 0 then Cons x rest else rest\n    end\nend"
        },
        {
            "description": "Implementation using a mapping function that returns option types, then a filter to remove None.",
            "implementation": "module HumanEval030\n  use import list.List\n  use import option.Option\n  let map_pos (x: int) : option int = if x > 0 then Some x else None\n  let rec filter_map (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n        match map_pos x with\n        | Some v -> Cons v (filter_map xs)\n        | None -> filter_map xs\n        end\n    end\n  let get_positive (l: list int) : list int = filter_map l\nend"
        },
        {
            "description": "Implementation using built-in filter with a predicate function (if filter is available).",
            "implementation": "module HumanEval030\n  use import list.List\n  predicate positive (x: int) = x > 0\n  let rec filter (p: int -> bool) (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if p x then Cons x (filter p xs) else filter p xs\n    end\n  let get_positive (l: list int) : list int = filter positive l\nend"
        },
        {
            "description": "Implementation using a fold to accumulate only positive numbers.",
            "implementation": "module HumanEval030\n  use import list.List\n  let rec fold_left (f: 'a -> int -> 'a) (acc: 'a) (l: list int) : 'a =\n    match l with\n    | Nil -> acc\n    | Cons x xs -> fold_left f (f acc x) xs\n    end\n  let get_positive (l: list int) : list int =\n    let f (acc: list int) (x: int) : list int = if x > 0 then Cons x acc else acc in\n    reverse (fold_left f Nil l)\nend"
        },
        {
            "description": "Iterative approach using a while loop simulation (with an explicit recursive helper that mimics iteration).",
            "implementation": "module HumanEval030\n  use import list.List\n  let rec loop (l: list int) (acc: list int) : list int =\n    match l with\n    | Nil -> reverse acc\n    | Cons x xs -> loop xs (if x > 0 then Cons x acc else acc)\n    end\n  let get_positive (l: list int) : list int = loop l Nil\nend"
        },
        {
            "description": "Recursive two-branch: split list in halves, process recursively, and merge (divide and conquer style).",
            "implementation": "module HumanEval030\n  use import list.List\n  use import int.Int\n  let rec length (l: list 'a) : int = match l with Nil -> 0 | Cons _ xs -> 1 + length xs end\n  let rec take (n: int) (l: list 'a) : list 'a =\n    if n = 0 then Nil else match l with Nil -> Nil | Cons x xs -> Cons x (take (n-1) xs) end\n  let rec drop (n: int) (l: list 'a) : list 'a =\n    if n = 0 then l else match l with Nil -> Nil | Cons _ xs -> drop (n-1) xs end\n  let rec merge (l1: list int) (l2: list int) : list int =\n    match l1 with Nil -> l2 | Cons x xs -> Cons x (merge xs l2) end\n  let rec get_positive (l: list int) : list int =\n    let len = length l in\n    if len <= 1 then (match l with Nil -> Nil | Cons x Nil -> if x > 0 then Cons x Nil else Nil | _ -> Nil end)\n    else\n      let mid = len / 2 in\n      let left = take mid l in\n      let right = drop mid l in\n      merge (get_positive left) (get_positive right)\nend"
        },
        {
            "description": "Implementation using a separate function to check positivity and recursively build the result.",
            "implementation": "module HumanEval030\n  use import list.List\n  let is_positive (x: int) : bool = x > 0\n  let rec get_positive (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n        if is_positive x then Cons x (get_positive xs) else get_positive xs\n    end\nend"
        },
        {
            "description": "Implementation using pattern matching guards (if available in Why3) for selection.",
            "implementation": "module HumanEval030\n  use import list.List\n  let rec get_positive (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs when x > 0 -> Cons x (get_positive xs)\n    | Cons _ xs -> get_positive xs\n    end\nend"
        }
    ]
}