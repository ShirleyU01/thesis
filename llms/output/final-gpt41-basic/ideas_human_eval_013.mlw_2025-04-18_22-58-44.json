{
    "ideas": [
        {
            "description": "Classic Euclidean algorithm using recursion. This is the standard approach for computing GCD.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if b = 0 then abs a else greatest_common_divisor b (a mod b)\nend"
        },
        {
            "description": "Iterative (loop-based) version of the Euclidean algorithm, avoiding recursion.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let greatest_common_divisor (a: int) (b: int) : int =\n    var x = abs a in\n    var y = abs b in\n    while y <> 0 do\n      let r = x mod y in\n      x <- y;\n      y <- r\n    done;\n    x\nend"
        },
        {
            "description": "Recursive Euclidean algorithm with arguments reordered for symmetry. This version always puts the smaller argument second.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if b = 0 then abs a\n    else if b > a then greatest_common_divisor b a\n    else greatest_common_divisor b (a mod b)\nend"
        },
        {
            "description": "Implementation using subtraction-based Euclidean algorithm (iterative version).",
            "implementation": "module HumanEval013\n  use import int.Int\n  let greatest_common_divisor (a: int) (b: int) : int =\n    var x = abs a in\n    var y = abs b in\n    while x <> y && x <> 0 && y <> 0 do\n      if x > y then x <- x - y else y <- y - x\n    done;\n    if x = 0 then y else x\nend"
        },
        {
            "description": "Recursive subtraction-based Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 then y\n    else if y = 0 then x\n    else if x = y then x\n    else if x > y then greatest_common_divisor (x - y) y\n    else greatest_common_divisor x (y - x)\nend"
        },
        {
            "description": "Euclidean algorithm using pattern matching to handle zero and negative inputs explicitly.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    match (a, b) with\n    | (0, b) -> abs b\n    | (a, 0) -> abs a\n    | (a, b) -> greatest_common_divisor b (a mod b)\n    end\nend"
        },
        {
            "description": "Euclidean algorithm using a helper function to always ensure non-negative arguments.",
            "implementation": "module HumanEval013\n  use import int.Int\n  let rec gcd_aux (a: int) (b: int) : int =\n    if b = 0 then a else gcd_aux b (a mod b)\n  let greatest_common_divisor (a: int) (b: int) : int = gcd_aux (abs a) (abs b)\nend"
        },
        {
            "description": "Binary GCD (Stein's algorithm) using bitwise operations (simulated via arithmetic, as Why3's int doesn't support bitwise ops by default).",
            "implementation": "module HumanEval013\n  use import int.Int\n  predicate even (x: int) = x mod 2 = 0\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 then y\n    else if y = 0 then x\n    else if x = y then x\n    else if even x && even y then 2 * greatest_common_divisor (x div 2) (y div 2)\n    else if even x then greatest_common_divisor (x div 2) y\n    else if even y then greatest_common_divisor x (y div 2)\n    else if x > y then greatest_common_divisor ((x - y) div 2) y\n    else greatest_common_divisor ((y - x) div 2) x\nend"
        },
        {
            "description": "Handle negative numbers and zeroes explicitly, and raise an assertion failure if both are zero.",
            "implementation": "module HumanEval013\n  use import int.Int\n  exception BothZero\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    if a = 0 && b = 0 then raise BothZero\n    else if b = 0 then abs a\n    else greatest_common_divisor b (a mod b)\nend"
        },
        {
            "description": "Naive implementation: search all possible divisors from min(a, b) down to 1 (inefficient, but correct for small numbers).",
            "implementation": "module HumanEval013\n  use import int.Int\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 && y = 0 then 0 else\n    let rec find_gcd (d: int) : int =\n      if d = 0 then 1\n      else if (x mod d = 0) && (y mod d = 0) then d\n      else find_gcd (d - 1)\n    in find_gcd (if x < y then x else y)\nend"
        }
    ]
}