{
    "ideas": [
        {
            "description": "Sort the list and find the smallest difference between adjacent elements.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.Permut\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec min_pair_in_sorted (l: list int) : (int, int, int) =\n    match l with\n    | Nil | Cons _ Nil -> (0, 0, max_int)\n    | Cons x (Cons y tl) ->\n      let (a, b, mind) = min_pair_in_sorted (Cons y tl) in\n      let d = abs (y - x) in\n      if d < mind then (x, y, d) else (a, b, mind)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = List.sort numbers in\n    let (a, b, _) = min_pair_in_sorted sorted in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Compare all pairs in the list to find the closest pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Mem\n  use list.Permut\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec find_min_pair (l: list int) (min_a: int) (min_b: int) (min_diff: int) : (int, int, int) =\n    match l with\n    | Nil -> (min_a, min_b, min_diff)\n    | Cons x tl ->\n      let rec aux (l2: list int) (min_a: int) (min_b: int) (min_diff: int) =\n        match l2 with\n        | Nil -> (min_a, min_b, min_diff)\n        | Cons y tl2 ->\n          let d = abs (x - y) in\n          if x < y then\n            if d < min_diff then aux tl2 x y d else aux tl2 min_a min_b min_diff\n          else\n            if d < min_diff then aux tl2 y x d else aux tl2 min_a min_b min_diff\n        end\n      in\n      let (a, b, d) = aux tl min_a min_b min_diff in\n      find_min_pair tl a b d\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y tl) ->\n      let (a, b, _) = find_min_pair numbers x y (abs (x - y)) in\n      Cons a (Cons b Nil)\n    end\nend"
        },
        {
            "description": "Use a fold to track the pair with the smallest difference as you go through all pairs.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let find_closest_elements (numbers: list int) : list int =\n    let rec aux (l: list int) (min_a: int) (min_b: int) (min_diff: int) : (int, int, int) =\n      match l with\n      | Nil -> (min_a, min_b, min_diff)\n      | Cons x tl ->\n        let rec inner (l2: list int) (min_a: int) (min_b: int) (min_diff: int) =\n          match l2 with\n          | Nil -> (min_a, min_b, min_diff)\n          | Cons y tl2 ->\n            let d = abs (x - y) in\n            let (a, b) = if x < y then (x, y) else (y, x) in\n            if d < min_diff then inner tl2 a b d else inner tl2 min_a min_b min_diff\n          end\n        in\n        let (a, b, d) = inner tl min_a min_b min_diff in\n        aux tl a b d\n      end\n    in\n    match numbers with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y tl) ->\n      let (a, b, _) = aux numbers x y (abs (x - y)) in\n      Cons a (Cons b Nil)\n    end\nend"
        },
        {
            "description": "Remove duplicates, sort, and find the closest pair among unique values.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Mem\n  use list.Length\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec remove_duplicates (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x tl -> if Mem.mem x tl then remove_duplicates tl else Cons x (remove_duplicates tl)\n    end\n\n  let rec min_pair_in_sorted (l: list int) : (int, int, int) =\n    match l with\n    | Nil | Cons _ Nil -> (0, 0, max_int)\n    | Cons x (Cons y tl) ->\n      let (a, b, mind) = min_pair_in_sorted (Cons y tl) in\n      let d = abs (y - x) in\n      if d < mind then (x, y, d) else (a, b, mind)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let unique = remove_duplicates numbers in\n    let sorted = List.sort unique in\n    let (a, b, _) = min_pair_in_sorted sorted in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Find the pair of equal numbers if present (since their difference is zero), otherwise find the closest pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Mem\n  use list.Length\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec find_equal_pair (l: list int) : option (int, int) =\n    match l with\n    | Nil -> None\n    | Cons x tl -> if Mem.mem x tl then Some (x, x) else find_equal_pair tl\n    end\n\n  let rec min_pair (l: list int) : (int, int, int) =\n    match l with\n    | Nil | Cons _ Nil -> (0, 0, max_int)\n    | Cons x tl ->\n      let rec check (l2: list int) (min_a: int) (min_b: int) (min_diff: int) =\n        match l2 with\n        | Nil -> (min_a, min_b, min_diff)\n        | Cons y tl2 ->\n          let d = abs (x - y) in\n          let (a, b) = if x < y then (x, y) else (y, x) in\n          if d < min_diff then check tl2 a b d else check tl2 min_a min_b min_diff\n        end\n      in\n      let (a, b, d) = check tl x x max_int in\n      let (a2, b2, d2) = min_pair tl in\n      if d < d2 then (a, b, d) else (a2, b2, d2)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match find_equal_pair numbers with\n    | Some (a,b) -> Cons a (Cons b Nil)\n    | None -> let (a, b, _) = min_pair numbers in Cons a (Cons b Nil)\n    end\nend"
        },
        {
            "description": "Use a recursive helper to keep track of the minimum difference and corresponding pair during traversal.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec find_closest_aux (l: list int) (cur_a: int) (cur_b: int) (cur_diff: int) : (int, int) =\n    match l with\n    | Nil -> (cur_a, cur_b)\n    | Cons x tl ->\n      let rec compare_rest (r: list int) (a: int) (b: int) (d: int) =\n        match r with\n        | Nil -> (a, b, d)\n        | Cons y tl2 ->\n          let diff = abs (x - y) in\n          let (na, nb) = if x < y then (x, y) else (y, x) in\n          if diff < d then compare_rest tl2 na nb diff else compare_rest tl2 a b d\n        end\n      in\n      let (a, b, d) = compare_rest tl cur_a cur_b cur_diff in\n      find_closest_aux tl a b d\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y tl) ->\n      let init_diff = abs (x - y) in\n      let (a, b) = find_closest_aux numbers x y init_diff in\n      Cons a (Cons b Nil)\n    end\nend"
        },
        {
            "description": "Use a brute-force approach with index tracking to avoid redundant comparisons.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let rec get_nth (l: list int) (n: int) : int =\n    match l with\n    | Nil -> 0\n    | Cons x tl -> if n = 0 then x else get_nth tl (n-1)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let len = Length.length numbers in\n    let rec aux i j min_a min_b min_diff =\n      if i = len then Cons min_a (Cons min_b Nil) else\n        if j = len then aux (i+1) (i+2) min_a min_b min_diff\n        else\n          let x = get_nth numbers i in\n          let y = get_nth numbers j in\n          let d = abs (x - y) in\n          let (a, b) = if x < y then (x, y) else (y, x) in\n          if d < min_diff then aux i (j+1) a b d else aux i (j+1) min_a min_b min_diff\n    in\n    match numbers with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y tl) ->\n      aux 0 1 x y (abs (x-y))\n    end\nend"
        },
        {
            "description": "First sort, then use a single pass through the sorted list to find the minimal adjacent pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Permut\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = List.sort numbers in\n    let rec aux l min_a min_b min_d =\n      match l with\n      | Nil | Cons _ Nil -> Cons min_a (Cons min_b Nil)\n      | Cons x (Cons y tl) ->\n        let d = abs (y - x) in\n        if d < min_d then aux (Cons y tl) x y d else aux (Cons y tl) min_a min_b min_d\n      end\n    in\n    match sorted with\n    | Cons x (Cons y tl) -> aux (Cons y tl) x y (abs (y-x))\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a map-reduce style: generate all pairs, map to differences, and reduce to the minimum.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  type pair = { a: int; b: int; d: int }\n\n  let rec pairs (l: list int) : list pair =\n    match l with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x tl ->\n      let rec make_pairs (l2: list int) : list pair =\n        match l2 with\n        | Nil -> Nil\n        | Cons y tl2 ->\n          let (a, b) = if x < y then (x, y) else (y, x) in\n          Cons { a = a; b = b; d = abs (x - y) } (make_pairs tl2)\n        end\n      in\n      List.app (make_pairs tl) (pairs tl)\n    end\n\n  let rec min_pair (l: list pair) (cur: pair) : pair =\n    match l with\n    | Nil -> cur\n    | Cons x tl -> if x.d < cur.d then min_pair tl x else min_pair tl cur\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y tl) ->\n      let ps = pairs numbers in\n      let init = { a = x; b = y; d = abs (x-y) } in\n      let res = min_pair ps init in\n      Cons res.a (Cons res.b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a tail-recursive helper that passes state for minimum difference and pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use list.List\n\n  function abs (x:int) : int = if x < 0 then -x else x\n\n  let find_closest_elements (numbers: list int) : list int =\n    let len = List.length numbers in\n    let rec loop i j min_a min_b min_d =\n      if i >= len then Cons min_a (Cons min_b Nil)\n      else if j >= len then loop (i+1) (i+2) min_a min_b min_d\n      else\n        let rec nth l n = match l with | Nil -> 0 | Cons x tl -> if n = 0 then x else nth tl (n-1) end in\n        let x = nth numbers i in\n        let y = nth numbers j in\n        let d = abs (x-y) in\n        if d < min_d then\n          let (a,b) = if x < y then (x,y) else (y,x) in\n          loop i (j+1) a b d\n        else\n          loop i (j+1) min_a min_b min_d\n    in\n    match numbers with\n    | Cons x (Cons y tl) -> loop 0 1 x y (abs (x-y))\n    | _ -> Nil\n    end\nend"
        }
    ]
}