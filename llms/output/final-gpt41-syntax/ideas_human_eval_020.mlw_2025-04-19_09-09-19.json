{
    "ideas": [
        {
            "description": "Brute-force all pairs: Iterate over all pairs of elements using two recursive loops, compute the absolute difference, and track the pair with the smallest difference.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec min_pair (l: list int) (t: list int) (min_diff: int) (pair: (int, int)) : (int, int) =\n    match l with\n    | Nil -> pair\n    | Cons x xs ->\n        let rec check_rest (l2: list int) (min_d: int) (p: (int, int)) : (int, int) =\n          match l2 with\n          | Nil -> p\n          | Cons y ys ->\n              let d = abs (x - y) in\n              if d < min_d then check_rest ys d (min x y, max x y) else check_rest ys min_d p\n          end\n        in\n        let np = check_rest t min_diff pair in\n        let nd = abs (fst np - snd np) in\n        min_pair xs xs nd np\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let (a,b) = min_pair numbers numbers (max_int) (0,0) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Sort and scan: Sort the list, then scan adjacent pairs to find the closest difference.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Sort\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec find_min_adj (l: list int) (min_diff: int) (pair: (int, int)) : (int, int) =\n    match l with\n    | Nil -> pair\n    | Cons x Nil -> pair\n    | Cons x (Cons y r) ->\n        let d = abs (x - y) in\n        if d < min_diff then find_min_adj (Cons y r) d (x, y) else find_min_adj (Cons y r) min_diff pair\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = sort numbers in\n    let (a, b) = find_min_adj sorted (max_int) (0, 0) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Recursive pairwise difference: Recursively compare the head to all elements in the tail, then recurse the tail.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec closest_to_head (x:int) (l: list int) (min_diff: int) (pair: (int,int)) : (int,int) =\n    match l with\n    | Nil -> pair\n    | Cons y ys ->\n      let d = abs (x - y) in\n      if d < min_diff then closest_to_head x ys d (min x y, max x y)\n      else closest_to_head x ys min_diff pair\n    end\n\n  let rec closest_in_list (l: list int) (min_diff:int) (pair: (int,int)) : (int,int) =\n    match l with\n    | Nil -> pair\n    | Cons x xs ->\n        let p = closest_to_head x xs min_diff pair in\n        let d = abs (fst p - snd p) in\n        closest_in_list xs d p\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let (a, b) = closest_in_list numbers (max_int) (0, 0) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Two-pass: First compute the minimum difference; second pass to find the first pair with this difference.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec min_diff (l: list int) (min_diff: int) : int =\n    match l with\n    | Nil -> min_diff\n    | Cons x xs ->\n        let rec loop2 (l2: list int) (cur_min: int) : int =\n          match l2 with\n          | Nil -> cur_min\n          | Cons y ys ->\n              let d = abs (x - y) in\n              if d < cur_min then loop2 ys d else loop2 ys cur_min\n          end\n        in\n        let nmin = loop2 xs min_diff in\n        min_diff xs nmin\n    end\n\n  let rec find_pair (l: list int) (d: int) : (int,int) =\n    match l with\n    | Nil -> (0,0)\n    | Cons x xs ->\n        let rec loop2 (l2: list int) : (int,int) =\n          match l2 with\n          | Nil -> find_pair xs d\n          | Cons y ys ->\n              let diff = abs (x - y) in\n              if diff = d then (min x y, max x y) else loop2 ys\n          end\n        in\n        loop2 xs\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let d = min_diff numbers (max_int) in\n    let (a, b) = find_pair numbers d in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Return the first minimal pair: As soon as a pair with the minimal difference is found, return it immediately (not all pairs considered).",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec first_min_pair (l: list int) (cur_min:int) (pair:(int,int)) : (int,int) =\n    match l with\n    | Nil -> pair\n    | Cons x xs ->\n        let rec find_first (l2: list int) : (bool, (int,int)) =\n          match l2 with\n          | Nil -> (false, pair)\n          | Cons y ys ->\n              let d = abs (x-y) in\n              if d < cur_min then (true, (min x y, max x y)) else find_first ys\n          end\n        in\n        let (found, p) = find_first xs in\n        if found then p else first_min_pair xs cur_min pair\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let (a, b) = first_min_pair numbers (max_int) (0, 0) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Find all pairs with minimal difference, then select lex smallest (smaller number first).",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n  use list.Append\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec collect_pairs (l: list int) (min_diff: int) : list (int,int) =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n        let rec loop2 (l2: list int) : list (int,int) =\n          match l2 with\n          | Nil -> Nil\n          | Cons y ys ->\n              let d = abs (x-y) in\n              if d = min_diff then Cons (min x y, max x y) (loop2 ys) else loop2 ys\n          end\n        in\n        (loop2 xs) ++ (collect_pairs xs min_diff)\n    end\n\n  let rec min_diff (l: list int) (cur_min:int) : int =\n    match l with\n    | Nil -> cur_min\n    | Cons x xs ->\n        let rec loop2 (l2: list int) (cmin:int) : int =\n          match l2 with\n          | Nil -> cmin\n          | Cons y ys ->\n              let d = abs (x-y) in\n              if d < cmin then loop2 ys d else loop2 ys cmin\n          end\n        in\n        let nmin = loop2 xs cur_min in\n        min_diff xs nmin\n    end\n\n  let rec min_lex_pair (l: list (int,int)) (pair:(int,int)) : (int,int) =\n    match l with\n    | Nil -> pair\n    | Cons (a,b) rest ->\n        if a < fst pair || (a = fst pair && b < snd pair) then min_lex_pair rest (a,b) else min_lex_pair rest pair\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let d = min_diff numbers (max_int) in\n    let pairs = collect_pairs numbers d in\n    let (a, b) = min_lex_pair pairs (max_int,max_int) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Divide and conquer: Split the list into two halves, recursively find closest pairs in each and across.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec take (n:int) (l: list int) : list int =\n    requires { n >= 0 }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if n = 0 then Nil else Cons x (take (n-1) xs)\n    end\n\n  let rec drop (n:int) (l: list int) : list int =\n    requires { n >= 0 }\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> if n = 0 then Cons x xs else drop (n-1) xs\n    end\n\n  let rec min_pair (l: list int) (min_diff: int) (pair: (int, int)) : (int, int) =\n    match l with\n    | Nil -> pair\n    | Cons x xs ->\n        let rec check_rest (l2: list int) (min_d: int) (p: (int, int)) : (int, int) =\n          match l2 with\n          | Nil -> p\n          | Cons y ys ->\n              let d = abs (x - y) in\n              if d < min_d then check_rest ys d (min x y, max x y) else check_rest ys min_d p\n          end\n        in\n        let np = check_rest xs min_diff pair in\n        let nd = abs (fst np - snd np) in\n        min_pair xs nd np\n    end\n\n  let rec merge_min (a:(int,int)) (b:(int,int)) : (int,int) =\n    let d1 = abs (fst a - snd a) in\n    let d2 = abs (fst b - snd b) in\n    if d1 <= d2 then a else b\n\n  let rec closest_divide (l: list int) : (int,int) =\n    let n = length l in\n    if n = 2 then\n      match l with | Cons x (Cons y Nil) -> (min x y, max x y) | _ -> (0,0) end\n    else\n      let m = n div 2 in\n      let left = take m l in\n      let right = drop m l in\n      let p1 = closest_divide left in\n      let p2 = closest_divide right in\n      let p3 = min_pair left right (max_int) (0,0) in\n      merge_min p1 (merge_min p2 p3)\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let (a, b) = closest_divide numbers in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Iterative version using indices: Simulate double loop using indices and helper nth function.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x xs -> if n = 0 then x else nth_my (n-1) xs\n    end\n\n  let rec loop_i (i:int) (n:int) (l: list int) (min_diff:int) (pair:(int,int)) : (int,int) =\n    if i >= n then pair\n    else\n      let xi = nth_my i l in\n      let rec loop_j (j:int) (min_d:int) (p:(int,int)) : (int,int) =\n        if j >= n then p\n        else\n          let xj = nth_my j l in\n          let d = abs (xi - xj) in\n          if i <> j && d < min_d then loop_j (j+1) d (min xi xj, max xi xj) else loop_j (j+1) min_d p\n      in\n      let p2 = loop_j 0 min_diff pair in\n      let d2 = abs (fst p2 - snd p2) in\n      loop_i (i+1) n l d2 p2\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let (a,b) = loop_i 0 n numbers (max_int) (0,0) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Scan for duplicates first: If duplicates are found, return them; else find the closest pair.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.MinMax\n\n  let rec has_duplicate (x:int) (l: list int) : bool =\n    match l with\n    | Nil -> false\n    | Cons y ys -> if x = y then true else has_duplicate x ys\n    end\n\n  let rec find_duplicate (l: list int) : (bool, (int,int)) =\n    match l with\n    | Nil -> (false, (0,0))\n    | Cons x xs -> if has_duplicate x xs then (true, (x,x)) else find_duplicate xs\n    end\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec min_pair (l: list int) (t: list int) (min_diff: int) (pair: (int, int)) : (int, int) =\n    match l with\n    | Nil -> pair\n    | Cons x xs ->\n        let rec check_rest (l2: list int) (min_d: int) (p: (int, int)) : (int, int) =\n          match l2 with\n          | Nil -> p\n          | Cons y ys ->\n              let d = abs (x - y) in\n              if d < min_d then check_rest ys d (min x y, max x y) else check_rest ys min_d p\n          end\n        in\n        let np = check_rest t min_diff pair in\n        let nd = abs (fst np - snd np) in\n        min_pair xs xs nd np\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let (found, (a,b)) = find_duplicate numbers in\n    if found then Cons a (Cons b Nil)\n    else let (c,d) = min_pair numbers numbers (max_int) (0,0) in Cons c (Cons d Nil)\nend"
        },
        {
            "description": "Use a running window over a sorted list to track minimal pairs, but handle the unsorted case by first sorting internally.",
            "implementation": "theory HumanEval020\n  use int.Int\n  use list.List\n  use list.Length\n  use list.Sort\n  use int.MinMax\n\n  let abs (x:int) : int = if x < 0 then -x else x\n\n  let rec scan_adj (l: list int) (min_diff:int) (pair:(int,int)) : (int,int) =\n    match l with\n    | Nil -> pair\n    | Cons x Nil -> pair\n    | Cons x (Cons y r) ->\n        let d = abs (x-y) in\n        if d < min_diff then scan_adj (Cons y r) d (x,y) else scan_adj (Cons y r) min_diff pair\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = sort numbers in\n    let (a,b) = scan_adj sorted (max_int) (0,0) in\n    Cons a (Cons b Nil)\nend"
        }
    ]
}