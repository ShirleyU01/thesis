{
    "ideas": [
        {
            "description": "Classic iterative trial division up to sqrt(n): Checks divisibility from 2 up to floor(sqrt(n)). Returns false if any divisor is found, true otherwise.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let rec check (d: int) : bool =\n      if d * d > n then true\n      else if mod n d = 0 then false\n      else check (d + 1)\n    in check 2\nend"
        },
        {
            "description": "Recursive trial division up to n-1: Checks divisibility from 2 up to n-1 recursively, returning false if any divisor is found.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let rec check (n: int) (d: int) : bool =\n    if d = n then true\n    else if mod n d = 0 then false\n    else check n (d + 1)\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else check n 2\nend"
        },
        {
            "description": "Iterative check only for odd divisors after 2: Checks divisibility by 2, then checks only odd divisors up to sqrt(n).",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else if n = 2 then true else if mod n 2 = 0 then false else\n    let rec check (d: int) : bool =\n      if d * d > n then true\n      else if mod n d = 0 then false\n      else check (d + 2)\n    in check 3\nend"
        },
        {
            "description": "Checks by building a list of all divisors and testing if any are factors: Uses a helper to check all numbers from 2 to n-1 and returns false if any divides n.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let rec has_factor (n: int) (d: int) : bool =\n    if d = n then false\n    else if mod n d = 0 then true\n    else has_factor n (d + 1)\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else not (has_factor n 2)\nend"
        },
        {
            "description": "Check for small primes and then for divisibility by 6k +/- 1 up to sqrt(n): Efficient for larger n, skips many composite numbers.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let is_prime (n: int) : bool =\n    if n <= 1 then false\n    else if n <= 3 then true\n    else if mod n 2 = 0 || mod n 3 = 0 then false\n    else\n      let rec check (i: int) : bool =\n        if i * i > n then true\n        else if mod n i = 0 || mod n (i + 2) = 0 then false\n        else check (i + 6)\n      in check 5\nend"
        },
        {
            "description": "Count the number of divisors and check if it's exactly 2 (1 and n): Counts the number of divisors and returns true if exactly 2.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let rec count_divisors (d: int) (cnt: int) : int =\n      if d > n then cnt\n      else if mod n d = 0 then count_divisors (d + 1) (cnt + 1)\n      else count_divisors (d + 1) cnt\n    in count_divisors 1 0 = 2\nend"
        },
        {
            "description": "Generate a list of possible divisors and check for factors using custom nth_my: Uses a list of integers from 2 to n-1 and checks if any divides n.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n  let rec range (a: int) (b: int) : list int =\n    if a > b then Nil else Cons a (range (a+1) b)\n  let rec has_factor (n: int) (l: list int) : bool =\n    match l with\n    | Nil -> false\n    | Cons x r -> if mod n x = 0 then true else has_factor n r\n    end\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else not (has_factor n (range 2 (n-1)))\nend"
        },
        {
            "description": "Check divisibility by all numbers up to n div 2: No number greater than n/2 except n divides n, so check up to n div 2.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let rec check (d: int) : bool =\n      if d > div n 2 then true\n      else if mod n d = 0 then false\n      else check (d + 1)\n    in check 2\nend"
        },
        {
            "description": "Check for primality using recursive pattern matching for edge cases (1, 2, even): Special-cases 2 and even numbers, then checks odd divisors.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let rec is_prime (n: int) : bool =\n    match n with\n    | 2 -> true\n    | _ ->\n        if n < 2 then false\n        else if mod n 2 = 0 then false\n        else\n          let rec helper (d: int) : bool =\n            if d * d > n then true\n            else if mod n d = 0 then false\n            else helper (d + 2)\n          in helper 3\n    end\nend"
        },
        {
            "description": "Check primality by verifying n is not a perfect square and not divisible by any number below sqrt(n): Adds an additional perfect square check.",
            "implementation": "module HumanEval031\n  use int.Int\n  use int.EuclideanDivision\n  let rec sqrt_approx (n: int) (guess: int) : int =\n    if guess * guess > n then guess - 1 else sqrt_approx n (guess + 1)\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let s = sqrt_approx n 1 in\n    if s * s = n then false\n    else\n      let rec check (d: int) : bool =\n        if d > s then true\n        else if mod n d = 0 then false\n        else check (d + 1)\n      in check 2\nend"
        }
    ]
}