{
    "ideas": [
        {
            "description": "Iterative approach using two nested for-loops to find the closest pair, then returns them in order.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  \n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref a = nth_my 0 numbers in\n    let ref b = nth_my 1 numbers in\n    for i = 0 to n-2 do\n      for j = i+1 to n-1 do\n        let x = nth_my i numbers in\n        let y = nth_my j numbers in\n        let d = abs (x - y) in\n        if d < min_diff then begin\n          min_diff <- d;\n          a <- min x y;\n          b <- max x y\n        end\n      done\n    done;\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Recursive approach traversing all pairs using helper function and accumulators to track minimum difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n\n  let rec find_closest_helper (l: list int) (current: int) (best: int) (a: int) (b: int) : (int, int, int) =\n    match l with\n    | Nil -> (best, a, b)\n    | Cons x xs ->\n      let d = abs (x - current) in\n      if d < best then find_closest_helper xs current d (min x current) (max x current)\n      else find_closest_helper xs current best a b\n    end\n\n  let rec aux (l: list int) (best: int) (a: int) (b: int) : (int, int) =\n    match l with\n    | Nil -> (a, b)\n    | Cons x xs ->\n      let (new_best, new_a, new_b) = find_closest_helper xs x best a b in\n      aux xs new_best new_a new_b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let first_diff = abs (x - y) in\n      let (a, b) = aux numbers first_diff (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Single-pass approach by first sorting the list, then finding the closest adjacent pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n\n  (* Insertion sort for list int *)\n  let rec insert (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n    end\n\n  let rec sort (l:list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (sort xs)\n    end\n\n  let rec closest_adjacent (l:list int) (min_diff: int) (a:int) (b:int) : (int, int) =\n    match l with\n    | Cons x (Cons y ys) ->\n      let d = abs (x - y) in\n      if d < min_diff then closest_adjacent (Cons y ys) d x y else closest_adjacent (Cons y ys) min_diff a b\n    | _ -> (a, b)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match sort numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = closest_adjacent (Cons x (Cons y xs)) (abs (x - y)) x y in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Recursive approach using two indices to scan all unique pairs without nested loops.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  \n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let rec scan_j (numbers: list int) (i: int) (j: int) (n: int) (min_diff: int) (a: int) (b: int) : (int, int, int) =\n    if j >= n then (min_diff, a, b)\n    else\n      let x = nth_my i numbers in\n      let y = nth_my j numbers in\n      let d = abs (x - y) in\n      if d < min_diff then scan_j numbers i (j+1) n d (min x y) (max x y)\n      else scan_j numbers i (j+1) n min_diff a b\n\n  let rec scan_i (numbers: list int) (i: int) (n: int) (min_diff: int) (a: int) (b: int) : (int, int) =\n    if i >= n-1 then (a, b)\n    else\n      let (new_min, new_a, new_b) = scan_j numbers i (i+1) n min_diff a b in\n      scan_i numbers (i+1) n new_min new_a new_b\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let x0 = nth_my 0 numbers in\n    let x1 = nth_my 1 numbers in\n    let (a, b) = scan_i numbers 0 n (abs (x0 - x1)) (min x0 x1) (max x0 x1) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Accumulate pairs as you traverse, keeping the closest found, using a single recursive function.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n\n  let rec closest_pair (l: list int) (min_diff: int) (a: int) (b: int) : (int, int, int) =\n    match l with\n    | Cons x xs ->\n      let rec aux (ys: list int) (min_diff: int) (a: int) (b: int) : (int, int, int) =\n        match ys with\n        | Nil -> (min_diff, a, b)\n        | Cons y ys' ->\n          let d = abs (x - y) in\n          if d < min_diff then aux ys' d (min x y) (max x y)\n          else aux ys' min_diff a b\n        end\n      in\n      let (new_min, new_a, new_b) = aux xs min_diff a b in\n      closest_pair xs new_min new_a new_b\n    | Nil -> (min_diff, a, b)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b, c) = closest_pair (Cons x (Cons y xs)) (abs (x - y)) (min x y) (max x y) in\n      Cons b (Cons c Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "First computes all possible pairs and their differences, then finds the pair with the minimum difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Append\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let rec all_pairs (numbers: list int) (i: int) (n: int) : list (int, int, int) =\n    if i >= n-1 then Nil\n    else\n      let rec aux (j: int) : list (int, int, int) =\n        if j >= n then Nil\n        else\n          let x = nth_my i numbers in\n          let y = nth_my j numbers in\n          let d = abs (x - y) in\n          Cons (d, x, y) (aux (j+1))\n      in\n      aux (i+1) ++ all_pairs numbers (i+1) n\n\n  let rec min_pair (l: list (int, int, int)) (min_d:int) (a:int) (b:int) : (int, int) =\n    match l with\n    | Nil -> (a, b)\n    | Cons (d, x, y) xs ->\n      if d < min_d then min_pair xs d (min x y) (max x y)\n      else min_pair xs min_d a b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let x0 = nth_my 0 numbers in\n    let x1 = nth_my 1 numbers in\n    let pairs = all_pairs numbers 0 n in\n    let (a, b) = min_pair pairs (abs (x0 - x1)) (min x0 x1) (max x0 x1) in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Iterative approach using while-loop for both indices to scan all pairs for minimum difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref a = nth_my 0 numbers in\n    let ref b = nth_my 1 numbers in\n    let ref i = 0 in\n    while i < n-1 do\n      let ref j = i+1 in\n      while j < n do\n        let x = nth_my i numbers in\n        let y = nth_my j numbers in\n        let d = abs (x - y) in\n        if d < min_diff then begin\n          min_diff <- d;\n          a <- min x y;\n          b <- max x y\n        end;\n        j <- j + 1\n      done;\n      i <- i + 1\n    done;\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Recursive approach comparing only adjacent elements in an already sorted list.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n\n  let rec insert (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n    end\n\n  let rec sort (l:list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (sort xs)\n    end\n\n  let rec adjacent_min (l: list int) (min_diff: int) (a: int) (b: int) : (int, int) =\n    match l with\n    | Cons x (Cons y xs) ->\n      let d = abs (x - y) in\n      if d < min_diff then adjacent_min (Cons y xs) d x y else adjacent_min (Cons y xs) min_diff a b\n    | _ -> (a, b)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match sort numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = adjacent_min (Cons x (Cons y xs)) (abs (x - y)) x y in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Pairwise scan using an accumulator in a helper function, only updating result when a smaller difference is found.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n\n  let rec scan_pairs (l: list int) (min_diff: int) (a: int) (b: int) : (int, int) =\n    match l with\n    | Cons x xs ->\n      let rec aux (ys: list int) (min_diff: int) (a: int) (b: int) : (int, int) =\n        match ys with\n        | Nil -> (min_diff, a, b)\n        | Cons y ys' ->\n          let d = abs (x - y) in\n          if d < min_diff then aux ys' d (min x y) (max x y)\n          else aux ys' min_diff a b\n        end\n      in\n      let (new_min, new_a, new_b) = aux xs min_diff a b in\n      let (_, a2, b2) = scan_pairs xs new_min new_a new_b in\n      (new_min, a2, b2)\n    | Nil -> (min_diff, a, b)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (_, a, b) = scan_pairs (Cons x (Cons y xs)) (abs (x - y)) (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "First reverse the list, then scan all pairs to find the closest, to demonstrate order independence.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Reverse\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n-1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let rev_numbers = reverse numbers in\n    let n = length rev_numbers in\n    let ref min_diff = abs (nth_my 0 rev_numbers - nth_my 1 rev_numbers) in\n    let ref a = nth_my 0 rev_numbers in\n    let ref b = nth_my 1 rev_numbers in\n    for i = 0 to n-2 do\n      for j = i+1 to n-1 do\n        let x = nth_my i rev_numbers in\n        let y = nth_my j rev_numbers in\n        let d = abs (x - y) in\n        if d < min_diff then begin\n          min_diff <- d;\n          a <- min x y;\n          b <- max x y\n        end\n      done\n    done;\n    Cons a (Cons b Nil)\nend"
        }
    ]
}