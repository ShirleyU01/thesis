{
    "ideas": [
        {
            "description": "Iterate with a for-loop over all consecutive pairs, checking if the list is all non-decreasing or all non-increasing.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n  let monotonic (l : list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let ref inc = true in\n    let ref dec = true in\n    for i = 1 to n-1 do\n      if nth_my i l < nth_my (i-1) l then inc <- false;\n      if nth_my i l > nth_my (i-1) l then dec <- false;\n    done;\n    inc || dec\nend"
        },
        {
            "description": "Use recursion and pattern matching to compare each pair of elements for increasing or decreasing property.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then is_increasing (Cons y r) else false\n    end\n  let rec is_decreasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x >= y then is_decreasing (Cons y r) else false\n    end\n  let monotonic (l: list int) : bool =\n    is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Use a recursive helper with an accumulator to keep track of the expected direction (+1 for increasing, -1 for decreasing, 0 for undetermined initially).",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec check_dir (l: list int) (dir: int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) ->\n      if dir = 0 then\n        if x < y then check_dir (Cons y r) 1\n        else if x > y then check_dir (Cons y r) (-1)\n        else check_dir (Cons y r) 0\n      else if dir = 1 then\n        if x <= y then check_dir (Cons y r) 1 else false\n      else\n        if x >= y then check_dir (Cons y r) (-1) else false\n    end\n  let monotonic (l: list int) : bool =\n    check_dir l 0\nend"
        },
        {
            "description": "Use two recursive helpers (one for non-decreasing, one for non-increasing) and combine their results at top level.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec non_decreasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then non_decreasing (Cons y r) else false\n    end\n  let rec non_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x >= y then non_increasing (Cons y r) else false\n    end\n  let monotonic (l: list int) : bool =\n    non_decreasing l || non_increasing l\nend"
        },
        {
            "description": "Iterate with a while-loop over the list elements, tracking if only one direction is allowed.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n  let monotonic (l: list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let ref i = 1 in\n    let ref inc = true in\n    let ref dec = true in\n    while i < n do\n      if nth_my i l < nth_my (i-1) l then inc <- false;\n      if nth_my i l > nth_my (i-1) l then dec <- false;\n      i <- i + 1\n    done;\n    inc || dec\nend"
        },
        {
            "description": "Use for_all from list.Quant library to check all pairs for non-decreasing and non-increasing condition.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Quant\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n  let is_non_decreasing (l: list int) : bool =\n    let n = length l in\n    for_all (fun i: int -> nth_my (i-1) l <= nth_my i l) (1) (n-1)\n  let is_non_increasing (l: list int) : bool =\n    let n = length l in\n    for_all (fun i: int -> nth_my (i-1) l >= nth_my i l) (1) (n-1)\n  let monotonic (l: list int) : bool =\n    let n = length l in\n    if n <= 1 then true else is_non_decreasing l || is_non_increasing l\nend"
        },
        {
            "description": "Recursively check the first direction change and continue only if all subsequent pairs match this direction.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec get_direction (l: list int) : int =\n    match l with\n    | Cons x (Cons y r) ->\n        if x < y then 1 else if x > y then -1 else get_direction (Cons y r)\n    | _ -> 0\n    end\n  let rec check_dir (l: list int) (dir: int) : bool =\n    match l with\n    | Cons x (Cons y r) ->\n        if dir = 1 then (x <= y && check_dir (Cons y r) dir)\n        else if dir = -1 then (x >= y && check_dir (Cons y r) dir)\n        else check_dir (Cons y r) dir\n    | _ -> true\n    end\n  let monotonic (l: list int) : bool =\n    check_dir l (get_direction l)\nend"
        },
        {
            "description": "Recursively traverse the list and count the number of direction changes; monotonic if changes <=1.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec count_changes (l: list int) (prev: int) (dir: int) (changes: int) : int =\n    match l with\n    | Nil -> changes\n    | Cons x r ->\n        let newdir = if prev < x then 1 else if prev > x then -1 else dir in\n        let newchanges = if dir <> 0 && newdir <> dir && newdir <> 0 then changes + 1 else changes in\n        count_changes r x newdir newchanges\n    end\n  let monotonic (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x r -> count_changes r x 0 0 <= 1\n    end\nend"
        },
        {
            "description": "Fold recursively through the list with two accumulators indicating if increasing and decreasing are still possible.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  let rec fold_monotonic (l: list int) (inc: bool) (dec: bool) (prev: int) : (bool, bool) =\n    match l with\n    | Nil -> (inc, dec)\n    | Cons x r ->\n        let inc' = inc && prev <= x in\n        let dec' = dec && prev >= x in\n        fold_monotonic r inc' dec' x\n    end\n  let monotonic (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x r -> let (inc, dec) = fold_monotonic r true true x in inc || dec\n    end\nend"
        },
        {
            "description": "Check monotonicity by reversing the list and using the same increasing check on both original and reversed lists.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Reverse\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y r) -> if x <= y then is_increasing (Cons y r) else false\n    end\n  let monotonic (l: list int) : bool =\n    is_increasing l || is_increasing (reverse l)\nend"
        }
    ]
}