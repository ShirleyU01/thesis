{
    "ideas": [
        {
            "description": "Iterative implementation using while-loop and Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    while y <> 0 do\n      let r = mod x y in\n      x <- y;\n      y <- r\n    done;\n    x\nend"
        },
        {
            "description": "Recursive implementation using the Euclidean algorithm (classic recursion).",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if y = 0 then x else greatest_common_divisor y (mod x y)\nend"
        },
        {
            "description": "Recursive implementation using subtraction-based Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if y = 0 then x\n    else if x > y then greatest_common_divisor (x - y) y\n    else greatest_common_divisor x (y - x)\nend"
        },
        {
            "description": "Iterative implementation using subtraction-based Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    while x <> y && x <> 0 && y <> 0 do\n      if x > y then x <- x - y else y <- y - x\n    done ;\n    if x = 0 then y else x\nend"
        },
        {
            "description": "Iterative implementation using for-loop to check all common divisors from min(a,b) down to 1.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.MinMax\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    let ref res = 1 in\n    for i = m downto 1 do\n      if mod x i = 0 && mod y i = 0 then res <- i\n    done;\n    res\nend"
        },
        {
            "description": "Recursive implementation with accumulator, checking divisors from min(a,b) down to 1.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.MinMax\n  use int.EuclideanDivision\n  let rec helper (x: int) (y: int) (d: int) : int =\n    if d = 0 then 1\n    else if mod x d = 0 && mod y d = 0 then d\n    else helper x y (d - 1)\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    helper x y m\nend"
        },
        {
            "description": "Recursive implementation using pattern matching and swapping to ensure b <= a.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    match y with\n    | 0 -> x\n    | _ -> greatest_common_divisor y (mod x y)\n    end\nend"
        },
        {
            "description": "Implementation using a helper function to compute GCD for negative numbers by taking absolute value first.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec gcd_abs (x: int) (y: int) : int =\n    if y = 0 then x else gcd_abs y (mod x y)\n  let greatest_common_divisor (a: int) (b: int) : int =\n    gcd_abs (abs a) (abs b)\nend"
        },
        {
            "description": "Iterative implementation using a temporary variable to swap values if needed and apply Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let greatest_common_divisor (a: int) (b: int) : int =\n    let ref x = abs a in\n    let ref y = abs b in\n    while y <> 0 do\n      let tmp = y in\n      y <- mod x y;\n      x <- tmp\n    done;\n    x\nend"
        },
        {
            "description": "Implementation using recursion and branching to explicitly handle the case where either input is zero.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.EuclideanDivision\n  let rec greatest_common_divisor (a: int) (b: int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 then y\n    else if y = 0 then x\n    else greatest_common_divisor y (mod x y)\nend"
        }
    ]
}