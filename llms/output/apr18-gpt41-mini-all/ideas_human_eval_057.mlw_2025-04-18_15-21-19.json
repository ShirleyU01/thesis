{
    "ideas": [
        {
            "description": "Recursive check with two helper functions to verify monotonically increasing or monotonically decreasing separately, then combine results.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Cons x (Cons y xs) -> (x <= y) && is_increasing (Cons y xs)\n    | _ -> true\n    end\n\n  let rec is_decreasing (l: list int) : bool =\n    match l with\n    | Cons x (Cons y xs) -> (x >= y) && is_decreasing (Cons y xs)\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    is_increasing l || is_decreasing l\nend"
        },
        {
            "description": "Recursive implementation with an accumulator that tracks the trend (1 for increasing, -1 for decreasing, 0 for unknown) and ensures consistency throughout the list.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec check_trend (l: list int) (trend: int) : bool =\n    match l with\n    | Cons x (Cons y xs) ->\n      let diff = if x < y then 1 else if x > y then -1 else 0 in\n      if trend = 0 then check_trend (Cons y xs) diff\n      else if diff = 0 || diff = trend then check_trend (Cons y xs) trend\n      else false\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    check_trend l 0\nend"
        },
        {
            "description": "Iterative-style recursion with an inner recursive helper that compares adjacent elements and accumulates bool flags for increasing and decreasing, returning their disjunction.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec helper (l: list int) (increasing: bool) (decreasing: bool) : bool =\n    match l with\n    | Cons x (Cons y xs) ->\n      let inc = increasing && (x <= y) in\n      let dec = decreasing && (x >= y) in\n      if inc || dec then helper (Cons y xs) inc dec else false\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    helper l true true\nend"
        },
        {
            "description": "Check monotonicity by recursively comparing pairs and using pattern matching to immediately return false if any violation is found, otherwise true if list is empty or single element.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec monotonic_inc (l: list int) : bool =\n    match l with\n    | Cons x (Cons y xs) -> if x > y then false else monotonic_inc (Cons y xs)\n    | _ -> true\n    end\n\n  let rec monotonic_dec (l: list int) : bool =\n    match l with\n    | Cons x (Cons y xs) -> if x < y then false else monotonic_dec (Cons y xs)\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    monotonic_inc l || monotonic_dec l\nend"
        },
        {
            "description": "Reverse the list and check if the original is increasing or the reversed is increasing to determine monotonicity, relying on a helper for increasing check.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Reverse\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Cons x (Cons y xs) -> (x <= y) && is_increasing (Cons y xs)\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    is_increasing l || is_increasing (reverse l)\nend"
        },
        {
            "description": "Use an explicit index-based recursion with nth_my to check increasing and decreasing separately by comparing elements at index i and i+1.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec check_increasing (l: list int) (i: int) : bool =\n    if i >= (length l) - 1 then true\n    else if nth_my i l <= nth_my (i + 1) l then check_increasing l (i + 1) else false\n\n  let rec check_decreasing (l: list int) (i: int) : bool =\n    if i >= (length l) - 1 then true\n    else if nth_my i l >= nth_my (i + 1) l then check_decreasing l (i + 1) else false\n\n  let monotonic (l : list int) : bool =\n    if length l <= 1 then true else\n    check_increasing l 0 || check_decreasing l 0\nend"
        },
        {
            "description": "Flatten the list into pairs of adjacent elements and recursively check if all pairs satisfy increasing or decreasing condition using pattern matching on pair list.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Append\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  type pair = (int, int)\n\n  let rec pairs (l: list int) : list pair =\n    match l with\n    | Cons x (Cons y xs) -> Cons (x, y) (pairs (Cons y xs))\n    | _ -> Nil\n    end\n\n  let rec all_increasing (ps: list pair) : bool =\n    match ps with\n    | Cons (a,b) xs -> (a <= b) && all_increasing xs\n    | Nil -> true\n    end\n\n  let rec all_decreasing (ps: list pair) : bool =\n    match ps with\n    | Cons (a,b) xs -> (a >= b) && all_decreasing xs\n    | Nil -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    let ps = pairs l in\n    all_increasing ps || all_decreasing ps\nend"
        },
        {
            "description": "Use a recursive helper that returns option int for trend and returns false if trend changes, or true otherwise for monotonicity check.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  type option_int = None | Some int\n\n  let rec check_trend_opt (l: list int) (trend: option_int) : bool =\n    match l with\n    | Cons x (Cons y xs) ->\n      let new_trend =\n        if x < y then Some 1\n        else if x > y then Some (-1)\n        else trend\n      in\n      match trend, new_trend with\n      | None, _ -> check_trend_opt (Cons y xs) new_trend\n      | Some t, Some nt -> if t = nt then check_trend_opt (Cons y xs) trend else false\n      | Some _, None -> check_trend_opt (Cons y xs) trend\n      | None, None -> check_trend_opt (Cons y xs) trend\n      end\n    | _ -> true\n    end\n\n  let monotonic (l : list int) : bool =\n    check_trend_opt l None\nend"
        },
        {
            "description": "Check monotonicity by first counting the number of increasing and decreasing adjacent pairs and ensuring one of these counts equal to number of adjacent pairs.",
            "implementation": "module HumanEval057\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\n      n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec count_increasing (l: list int) : int =\n    match l with\n    | Cons x (Cons y xs) -> (if x <= y then 1 else 0) + count_increasing (Cons y xs)\n    | _ -> 0\n    end\n\n  let rec count_decreasing (l: list int) : int =\n    match l with\n    | Cons x (Cons y xs) -> (if x >= y then 1 else 0) + count_decreasing (Cons y xs)\n    | _ -> 0\n    end\n\n  let monotonic (l : list int) : bool =\n    let n = length l in\n    if n <= 1 then true else\n    let adjacent_count = n - 1 in\n    let inc = count_increasing l in\n    let dec = count_decreasing l in\n    inc = adjacent_count || dec = adjacent_count\nend"
        }
    ]
}