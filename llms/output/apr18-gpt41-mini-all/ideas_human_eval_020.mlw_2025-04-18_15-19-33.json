{
    "ideas": [
        {
            "description": "Sort the list first, then find the minimum difference between consecutive elements. Return the pair with the smallest difference.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Map\n  use list.Reverse\n  use list.SortedInt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec sort (l: list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> let rec insert (y: int) (lst: list int) : list int =\n        match lst with\n        | Nil -> Cons y Nil\n        | Cons z zs -> if y <= z then Cons y (Cons z zs) else Cons z (insert y zs)\n        end\n      in insert x (sort xs)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    let rec find_min_diff (lst: list int) (prev: int) (min_diff: int) (res: (int, int)) : (int, int) =\n      match lst with\n      | Nil -> res\n      | Cons x xs ->\n        let diff = if x >= prev then x - prev else prev - x in\n        if diff < min_diff then find_min_diff xs x diff (prev, x) else find_min_diff xs x min_diff res\n      end\n    in\n    match sorted with\n    | Cons x (Cons y ys) ->\n      let (a, b) = find_min_diff (Cons y ys) x (if y >= x then y - x else x - y) (x, y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a recursive approach to compare every pair of elements and keep track of the closest pair found so far.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_closest_pair_from (lst: list int) (x: int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons y ys ->\n      let diff = if x >= y then x - y else y - x in\n      if diff < min_diff then find_closest_pair_from ys x diff (min x y, max x y)\n      else find_closest_pair_from ys x min_diff res\n    end\n\n  let rec find_closest_elements_aux (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let (a,b) = find_closest_pair_from xs x min_diff res in\n      let new_min = if b - a < min_diff then b - a else min_diff in\n      let new_res = if b - a < min_diff then (a,b) else res in\n      find_closest_elements_aux xs new_min new_res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let (a,b) = find_closest_elements_aux numbers (if y >= x then y - x else x - y) (min x y, max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a nested loop style recursion where the outer recursion picks the first element, and the inner recursion compares with all others to find minimal difference.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_min_with_x (x: int) (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons y ys ->\n      let diff = if x >= y then x - y else y - x in\n      if diff < min_diff then find_min_with_x x ys diff (min x y, max x y)\n      else find_min_with_x x ys min_diff res\n    end\n\n  let rec outer_loop (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let (a,b) = find_min_with_x x xs min_diff res in\n      let new_min = if b - a < min_diff then b - a else min_diff in\n      let new_res = if b - a < min_diff then (a,b) else res in\n      outer_loop xs new_min new_res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let (a,b) = outer_loop numbers (if y >= x then y - x else x - y) (min x y, max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Convert list to arrays (using lists only), sort it with insertion sort, then find minimal adjacent difference pair.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec insert_sorted (x: int) (lst: list int) : list int =\n    match lst with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x (Cons y ys) else Cons y (insert_sorted x ys)\n    end\n\n  let rec insertion_sort (lst: list int) : list int =\n    match lst with\n    | Nil -> Nil\n    | Cons x xs -> insert_sorted x (insertion_sort xs)\n    end\n\n  let rec find_min_adjacent (lst: list int) (prev: int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let diff = x - prev in\n      if diff < min_diff then find_min_adjacent xs x diff (prev, x) else find_min_adjacent xs x min_diff res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = insertion_sort numbers in\n    match sorted with\n    | Cons x (Cons y ys) ->\n      let (a,b) = find_min_adjacent (Cons y ys) x (y - x) (x,y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a recursive helper with accumulator parameters to track the minimum difference pair while traversing the list with a nested recursion.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_min_diff_inner (x: int) (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons y ys ->\n      let diff = if x >= y then x - y else y - x in\n      let (new_min, new_res) = if diff < min_diff then (diff, (min x y, max x y)) else (min_diff, res) in\n      find_min_diff_inner x ys new_min new_res\n    end\n\n  let rec find_min_diff_outer (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let (new_min, new_res) =\n        let (a,b) = find_min_diff_inner x xs min_diff res in\n        let diff = b - a in\n        if diff < min_diff then (diff, (a,b)) else (min_diff, res)\n      in\n      find_min_diff_outer xs new_min new_res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let init_diff = if y >= x then y - x else x - y in\n      let (a,b) = find_min_diff_outer numbers init_diff (min x y, max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Use a tail-recursive accumulator approach for the main function to track current closest pair while iterating through the list twice (nested).",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner_loop (x: int) (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons y ys ->\n      let diff = if x >= y then x - y else y - x in\n      if diff < min_diff then inner_loop x ys diff (min x y, max x y)\n      else inner_loop x ys min_diff res\n    end\n\n  let rec outer_loop (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let (a,b) = inner_loop x xs min_diff res in\n      let new_min = if b - a < min_diff then b - a else min_diff in\n      let new_res = if b - a < min_diff then (a,b) else res in\n      outer_loop xs new_min new_res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let init_diff = if y >= x then y - x else x - y in\n      let (a,b) = outer_loop numbers init_diff (min x y, max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Sort the list and then use a tail-recursive function to scan for the minimal adjacent difference pair, returning the pair in order.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec insert (x: int) (lst: list int) : list int =\n    match lst with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x (Cons y ys) else Cons y (insert x ys)\n    end\n\n  let rec sort (lst: list int) : list int =\n    match lst with\n    | Nil -> Nil\n    | Cons x xs -> insert x (sort xs)\n    end\n\n  let rec find_min_adj (lst: list int) (prev: int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let diff = x - prev in\n      if diff < min_diff then find_min_adj xs x diff (prev, x) else find_min_adj xs x min_diff res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    match sorted with\n    | Cons x (Cons y ys) ->\n      let (a,b) = find_min_adj (Cons y ys) x (y - x) (x,y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Using explicit recursion and pattern matching, compare head with all remaining elements to find closest pair, then recurse on tail.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec min_pair (p1: (int, int)) (p2: (int, int)) : (int, int) =\n    let d1 = (snd p1) - (fst p1) in\n    let d2 = (snd p2) - (fst p2) in\n    if d1 <= d2 then p1 else p2\n\n  let rec find_closest_with_x (x: int) (lst: list int) : (int, int) =\n    match lst with\n    | Nil -> (x,x)\n    | Cons y ys ->\n      let current = if x <= y then (x,y) else (y,x) in\n      let rest = find_closest_with_x x ys in\n      min_pair current rest\n    end\n\n  let rec find_closest_elements_aux (lst: list int) : (int, int) =\n    match lst with\n    | Nil -> (0,0)\n    | Cons x Nil -> (x,x)\n    | Cons x xs ->\n      let pair_with_x = find_closest_with_x x xs in\n      let best_in_rest = find_closest_elements_aux xs in\n      min_pair pair_with_x best_in_rest\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let (a,b) = find_closest_elements_aux numbers in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Use a double recursion with an accumulator for the minimal difference and pair, comparing all pairs without sorting.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec compare_with_all (x: int) (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons y ys ->\n      let diff = if x >= y then x - y else y - x in\n      let (new_diff, new_res) = if diff < min_diff then (diff, (min x y, max x y)) else (min_diff, res) in\n      compare_with_all x ys new_diff new_res\n    end\n\n  let rec find_pairs (lst: list int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let (new_diff, new_res) =\n        let (a,b) = compare_with_all x xs min_diff res in\n        let diff = b - a in\n        if diff < min_diff then (diff, (a,b)) else (min_diff, res)\n      in\n      find_pairs xs new_diff new_res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y ys) ->\n      let init_diff = if y >= x then y - x else x - y in\n      let (a,b) = find_pairs numbers init_diff (min x y, max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Sort the list with a custom quicksort implementation, then find the pair with the minimal adjacent difference.",
            "implementation": "module HumanEval020\n\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use int.Int\n  use int.MinMax\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec append (l1: list int) (l2: list int) : list int =\n    match l1 with\n    | Nil -> l2\n    | Cons x xs -> Cons x (append xs l2)\n    end\n\n  let rec filter_less (pivot: int) (lst: list int) : list int =\n    match lst with\n    | Nil -> Nil\n    | Cons x xs -> if x < pivot then Cons x (filter_less pivot xs) else filter_less pivot xs\n    end\n\n  let rec filter_geq (pivot: int) (lst: list int) : list int =\n    match lst with\n    | Nil -> Nil\n    | Cons x xs -> if x >= pivot then Cons x (filter_geq pivot xs) else filter_geq pivot xs\n    end\n\n  let rec quicksort (lst: list int) : list int =\n    match lst with\n    | Nil -> Nil\n    | Cons x xs ->\n      let less = quicksort (filter_less x xs) in\n      let geq = quicksort (filter_geq x xs) in\n      append less (Cons x geq)\n    end\n\n  let rec find_min_adjacent (lst: list int) (prev: int) (min_diff: int) (res: (int, int)) : (int, int) =\n    match lst with\n    | Nil -> res\n    | Cons x xs ->\n      let diff = x - prev in\n      if diff < min_diff then find_min_adjacent xs x diff (prev, x) else find_min_adjacent xs x min_diff res\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = quicksort numbers in\n    match sorted with\n    | Cons x (Cons y ys) ->\n      let (a,b) = find_min_adjacent (Cons y ys) x (y - x) (x,y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        }
    ]
}