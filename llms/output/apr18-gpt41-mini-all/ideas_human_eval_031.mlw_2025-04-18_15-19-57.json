{
    "ideas": [
        {
            "description": "Using for-loop to check divisors from 2 to n-1 and return false if any divides n exactly.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let ref i = 2 in\n    let ref prime = true in\n    while i < n do\n      if mod n i = 0 then prime <- false;\n      i <- i + 1\n    done;\n    prime\nend"
        },
        {
            "description": "Using recursion with an inner helper function that checks divisibility starting from 2 up to n-1.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let rec check_divisor (n: int) (d: int) : bool =\n    if d >= n then true else\n    if mod n d = 0 then false else check_divisor n (d + 1)\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else check_divisor n 2\nend"
        },
        {
            "description": "Optimize by checking divisors only up to the integer square root of n using recursion.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n  use int.MinMax\n\n  let rec check_divisor (n: int) (d: int) : bool =\n    if d * d > n then true else\n    if mod n d = 0 then false else check_divisor n (d + 1)\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else check_divisor n 2\nend"
        },
        {
            "description": "Using a while-loop to check divisibility up to sqrt(n) with early termination if divisor found.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n  use int.MinMax\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let limit =\n      let rec sqrt_iter (x: int) (acc: int) : int =\n        if acc * acc > x then acc - 1 else sqrt_iter x (acc + 1) in\n      sqrt_iter n 0\n    in\n    let ref i = 2 in\n    let ref prime = true in\n    while i <= limit do\n      if mod n i = 0 then prime <- false;\n      i <- i + 1\n    done;\n    prime\nend"
        },
        {
            "description": "Using list construction of potential divisors and recursion to check if any divides n.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n  use list.List\n  use list.Length\n\n  let rec from_to (start: int) (stop: int) : list int =\n    if start > stop then Nil else Cons start (from_to (start + 1) stop)\n\n  let rec check_list (n: int) (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x xs -> if mod n x = 0 then false else check_list n xs\n    end\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    check_list n (from_to 2 (n - 1))\nend"
        },
        {
            "description": "Using accumulator recursion that tries divisors from 2 up to sqrt(n) with explicit accumulator parameter.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n  use int.MinMax\n\n  let rec is_prime_acc (n: int) (d: int) : bool =\n    if d * d > n then true else\n    if mod n d = 0 then false else is_prime_acc n (d + 1)\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else is_prime_acc n 2\nend"
        },
        {
            "description": "Using pattern matching with recursion on divisors starting from 2, returning false immediately if divisible.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let rec is_prime_helper (n: int) (d: int) : bool =\n    match d with\n    | x when x * x > n -> true\n    | x -> if mod n x = 0 then false else is_prime_helper n (x + 1)\n    end\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else is_prime_helper n 2\nend"
        },
        {
            "description": "Using a for-loop with early return by raising an exception when divisor found (simulated with ref flag).",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else\n    let ref prime = true in\n    for i = 2 to n - 1 do\n      if mod n i = 0 then prime <- false\n    done;\n    prime\nend"
        },
        {
            "description": "Using a recursive function with branching: if divisible returns false, if reaches n returns true.",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let rec is_prime_rec (n: int) (d: int) : bool =\n    if d = n then true else\n    if mod n d = 0 then false else is_prime_rec n (d + 1)\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else is_prime_rec n 2\nend"
        },
        {
            "description": "Using a recursive function that uses Euclidean division and checks divisibility only for odd numbers (after 2).",
            "implementation": "module HumanEval031\n\n  use int.Int\n  use int.EuclideanDivision\n\n  let rec check_odd_divisor (n: int) (d: int) : bool =\n    if d * d > n then true else\n    if mod n d = 0 then false else check_odd_divisor n (d + 2)\n\n  let is_prime (n: int) : bool =\n    if n <= 1 then false else if n = 2 then true else\n    if mod n 2 = 0 then false else check_odd_divisor n 3\nend"
        }
    ]
}