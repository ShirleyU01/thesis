{
    "ideas": [
        {
            "description": "Iterative brute-force: Check all pairs using nested loops to find the pair with the smallest absolute difference, then return them sorted.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use list.List\n  use list.Length\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let min_diff = ref (abs (hd numbers).(Some 0) - (hd (tl numbers)).(Some 0)) in\n    let res_a = ref (hd numbers).(Some 0) in\n    let res_b = ref (hd (tl numbers)).(Some 0) in\n    let rec outer i l = match l with\n      | Nil -> ()\n      | Cons x xs -> let rec inner j l2 = match l2 with\n          | Nil -> ()\n          | Cons y ys -> let d = abs (x - y) in\n              if d < !min_diff then (min_diff := d; res_a := x; res_b := y);\n              inner (j+1) ys\n        in inner (i+1) xs; outer (i+1) xs\n    in outer 0 numbers;\n    let a = min !res_a !res_b in\n    let b = max !res_a !res_b in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Sort then scan: Sort the list, check adjacent elements only for minimal difference (since closest pair must be neighbors), return sorted pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.HdTl\n  let rec insert (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n  let rec insertion_sort (l:list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (insertion_sort xs)\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = insertion_sort numbers in\n    let rec aux prev l min_diff best_pair =\n      match l with\n      | Nil -> best_pair\n      | Cons x xs ->\n        let d = abs (x - prev) in\n        if d < min_diff then aux x xs d (Cons prev (Cons x Nil))\n        else aux x xs min_diff best_pair\n    in match sorted with\n      | Nil | Cons _ Nil -> sorted\n      | Cons a (Cons b xs) -> aux a (Cons b xs) (abs (b - a)) (Cons a (Cons b Nil))\nend"
        },
        {
            "description": "Recursive pair comparison: Recursively check all pairs, updating the best found so far, using a helper with accumulator parameters.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec find_pairs l1 l2 min_diff best_a best_b =\n    match l1 with\n    | Nil -> (best_a, best_b)\n    | Cons x xs ->\n      let rec check_y l2 min_diff best_a best_b =\n        match l2 with\n        | Nil -> (min_diff, best_a, best_b)\n        | Cons y ys ->\n          let d = abs (x - y) in\n          if d < min_diff then check_y ys d x y\n          else check_y ys min_diff best_a best_b\n      in\n      let (min_d, ba, bb) = check_y l2 min_diff best_a best_b in\n      find_pairs xs l2 min_d ba bb\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons a (Cons b xs) ->\n      let (res_a, res_b) = find_pairs numbers numbers (abs (a - b)) a b in\n      let low = min res_a res_b in\n      let high = max res_a res_b in\n      Cons low (Cons high Nil)\n    | _ -> numbers\nend"
        },
        {
            "description": "Use List.nth for index-based pair search: Iterate over all index pairs, using nth to retrieve elements.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Nth\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let min_diff = ref (abs ((nth 0 numbers).(Some 0) - (nth 1 numbers).(Some 0))) in\n    let res_a = ref ((nth 0 numbers).(Some 0)) in\n    let res_b = ref ((nth 1 numbers).(Some 0)) in\n    let i = ref 0 in\n    while !i < n do\n      let j = ref (!i + 1) in\n      while !j < n do\n        let a = (nth !i numbers).(Some 0) in\n        let b = (nth !j numbers).(Some 0) in\n        let d = abs (a - b) in\n        if d < !min_diff then (min_diff := d; res_a := a; res_b := b);\n        j := !j + 1\n      done;\n      i := !i + 1\n    done;\n    let low = min !res_a !res_b in\n    let high = max !res_a !res_b in\n    Cons low (Cons high Nil)\nend"
        },
        {
            "description": "Map all pairs to list of tuples (diff, a, b), then find minimum diff tuple and return its pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec all_pairs l = match l with\n    | Nil -> Nil\n    | Cons x xs -> let rec inner y rest = match rest with\n        | Nil -> Nil\n        | Cons z zs -> Cons (abs (x-z), x, z) (inner y zs)\n      in append (inner x xs) (all_pairs xs)\n  and append l1 l2 = match l1 with\n    | Nil -> l2\n    | Cons x xs -> Cons x (append xs l2)\n  let rec min_tuple l min_d a b = match l with\n    | Nil -> (a, b)\n    | Cons (d, x, y) xs ->\n      if d < min_d then min_tuple xs d x y\n      else min_tuple xs min_d a b\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons a (Cons b xs) ->\n      let pairs = all_pairs numbers in\n      let (res_a, res_b) = min_tuple pairs (abs (a-b)) a b in\n      let low = min res_a res_b in\n      let high = max res_a res_b in\n      Cons low (Cons high Nil)\n    | _ -> numbers\nend"
        },
        {
            "description": "Tail-recursive using explicit accumulator: Build a tail-recursive function that traverses all pairs with an accumulator for the best pair found.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec find_closest_aux l1 l2 min_diff best_pair =\n    match l1 with\n    | Nil -> best_pair\n    | Cons x xs ->\n      let rec inner l2 min_diff best_pair =\n        match l2 with\n        | Nil -> (min_diff, best_pair)\n        | Cons y ys ->\n          let d = abs (x-y) in\n          if d < min_diff then inner ys d (x, y)\n          else inner ys min_diff best_pair\n      in\n      let (min_d, best) = inner l2 min_diff best_pair in\n      find_closest_aux xs l2 min_d best\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons a (Cons b xs) ->\n      let (_, (res_a, res_b)) = find_closest_aux numbers numbers (abs (a-b)) (a, b) in\n      let low = min res_a res_b in\n      let high = max res_a res_b in\n      Cons low (Cons high Nil)\n    | _ -> numbers\nend"
        },
        {
            "description": "Sort and recursive adjacent comparison: Sort, then recursively check all adjacent pairs for minimal difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec insert x l = match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n  let rec insertion_sort l = match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (insertion_sort xs)\n  let rec find_min_adj l prev min_d min_pair =\n    match l with\n    | Nil -> min_pair\n    | Cons x xs ->\n      let d = abs (x - prev) in\n      if d < min_d then find_min_adj xs x d (Cons prev (Cons x Nil))\n      else find_min_adj xs x min_d min_pair\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = insertion_sort numbers in\n    match sorted with\n    | Cons a (Cons b xs) -> find_min_adj (Cons b xs) a (abs (b-a)) (Cons a (Cons b Nil))\n    | _ -> numbers\nend"
        },
        {
            "description": "Check only unique pairs with one-pass: For each element, compare with all following elements to avoid redundant comparisons.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec find_min l = match l with\n    | Nil -> (0, 0, max_int)\n    | Cons x xs ->\n      let rec check_rest y rest curr_min min_a min_b =\n        match rest with\n        | Nil -> (curr_min, min_a, min_b)\n        | Cons z zs ->\n          let d = abs (y-z) in\n          if d < curr_min then check_rest y zs d y z\n          else check_rest y zs curr_min min_a min_b\n      in\n      let (min_d, a, b) = check_rest x xs max_int 0 0 in\n      let (min_d2, a2, b2) = find_min xs in\n      if min_d < min_d2 then (min_d, a, b) else (min_d2, a2, b2)\n  let find_closest_elements (numbers: list int) : list int =\n    let (_, a, b) = find_min numbers in\n    let low = min a b in\n    let high = max a b in\n    Cons low (Cons high Nil)\nend"
        },
        {
            "description": "Parallel scan: Split the list into two halves, find closest in each, and across the boundary, then return the overall closest.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Prefix\n  let rec find_min_pair l =\n    match l with\n    | Nil | Cons _ Nil -> (max_int, 0, 0)\n    | Cons x (Cons y xs) ->\n      let d = abs (x-y) in\n      let (d2, a2, b2) = find_min_pair (Cons y xs) in\n      if d < d2 then (d, x, y) else (d2, a2, b2)\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let mid = n / 2 in\n    let left = prefix mid numbers in\n    let right =\n      let rec skip k l = if k = 0 then l else match l with Nil -> Nil | Cons _ xs -> skip (k-1) xs in\n      skip mid numbers\n    in\n    let (d1, a1, b1) = find_min_pair left in\n    let (d2, a2, b2) = find_min_pair right in\n    let (d3, a3, b3) =\n      match (left, right) with\n      | Cons l1 _, Cons r1 _ -> (abs (l1 - r1), l1, r1)\n      | _, _ -> (max_int, 0, 0)\n    in\n    if d1 <= d2 && d1 <= d3 then Cons (min a1 b1) (Cons (max a1 b1) Nil)\n    else if d2 <= d1 && d2 <= d3 then Cons (min a2 b2) (Cons (max a2 b2) Nil)\n    else Cons (min a3 b3) (Cons (max a3 b3) Nil)\nend"
        },
        {
            "description": "Pairwise sliding window: Slide a window of size 2 over the sorted list, collect all adjacent pairs, then select the minimal-difference one.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.MinMax\n  use int.Abs\n  use list.List\n  let rec insert x l = match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)\n  let rec insertion_sort l = match l with\n    | Nil -> Nil\n    | Cons x xs -> insert x (insertion_sort xs)\n  let rec pairs l = match l with\n    | Nil | Cons _ Nil -> Nil\n    | Cons x (Cons y ys) -> Cons (x, y) (pairs (Cons y ys))\n  let rec min_pair l min_d min_pair_val = match l with\n    | Nil -> min_pair_val\n    | Cons (a, b) xs ->\n      let d = abs (a - b) in\n      if d < min_d then min_pair xs d (a, b)\n      else min_pair xs min_d min_pair_val\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = insertion_sort numbers in\n    match sorted with\n    | Cons a (Cons b xs) ->\n      let p = pairs sorted in\n      let (res_a, res_b) = min_pair p (abs (a-b)) (a, b) in\n      let low = min res_a res_b in\n      let high = max res_a res_b in\n      Cons low (Cons high Nil)\n    | _ -> numbers\nend"
        }
    ]
}