{
    "ideas": [
        {
            "description": "Recursive check for monotonic increasing or decreasing: Recursively check if the list is strictly increasing, strictly decreasing, or contains all equal elements, by comparing each pair of adjacent elements.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.HdTl\n  use int.Int\n\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if x <= y then is_increasing (Cons y tl) else false\n    end\n\n  let rec is_decreasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if x >= y then is_decreasing (Cons y tl) else false\n    end\n\n  let monotonic (l: list int) : bool =\n    is_increasing l || is_decreasing l\nend\n"
        },
        {
            "description": "Iterative check using list tail: Use a helper function to loop through the list iteratively, comparing adjacent elements to determine increasing or decreasing trend.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.HdTl\n  use int.Int\n\n  let rec check (l: list int) (dir: int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) ->\n        if dir = 0 then\n          if x < y then check (Cons y tl) 1\n          else if x > y then check (Cons y tl) (-1)\n          else check (Cons y tl) 0\n        else if dir = 1 then\n          if x <= y then check (Cons y tl) 1 else false\n        else if dir = -1 then\n          if x >= y then check (Cons y tl) (-1) else false\n        else true\n    end\n\n  let monotonic (l: list int) : bool =\n    check l 0\nend\n"
        },
        {
            "description": "Using List.for_all to check increasing and decreasing: Use Quant.for_all to check if all adjacent pairs are increasing or all are decreasing.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.Quant\n  use int.Int\n\n  let rec all_adjacent (l: list int) (cmp: int -> int -> bool) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if cmp x y then all_adjacent (Cons y tl) cmp else false\n    end\n\n  let monotonic (l: list int) : bool =\n    all_adjacent l (<=) || all_adjacent l (>=)\nend\n"
        },
        {
            "description": "Check monotonicity by comparing the reversed list: If the list is not increasing, reverse it and check if it is increasing (i.e., decreasing originally).",
            "implementation": "module HumanEval057\n  use list.List\n  use list.Quant\n  use list.Reverse\n  use int.Int\n\n  let rec is_increasing (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if x <= y then is_increasing (Cons y tl) else false\n    end\n\n  let monotonic (l: list int) : bool =\n    is_increasing l || is_increasing (reverse l)\nend\n"
        },
        {
            "description": "Check for both monotonic increasing and decreasing in a single pass with flags: Traverse the list once and maintain two flags for increasing and decreasing; update them while comparing adjacent elements.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.HdTl\n  use int.Int\n\n  let monotonic (l: list int) : bool =\n    let rec aux (l: list int) (inc: bool) (dec: bool) : bool =\n      match l with\n      | Nil -> true\n      | Cons _ Nil -> true\n      | Cons x (Cons y tl) ->\n          let inc' = inc && (x <= y) in\n          let dec' = dec && (x >= y) in\n          if not inc' && not dec' then false else aux (Cons y tl) inc' dec'\n      end\n    in aux l true true\nend\n"
        },
        {
            "description": "Count direction changes: Traverse the list and count the number of times the direction changes. If more than one change, it's not monotonic.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l: list int) : bool =\n    let rec aux (l: list int) (dir: int) (changes: int) : bool =\n      match l with\n      | Nil -> true\n      | Cons _ Nil -> true\n      | Cons x (Cons y tl) ->\n          let d = if x < y then 1 else if x > y then -1 else 0 in\n          let changes' = if dir = 0 then changes else if d <> 0 && d <> dir then changes + 1 else changes in\n          let dir' = if d = 0 then dir else if dir = 0 then d else dir in\n          if changes' > 1 then false else aux (Cons y tl) dir' changes'\n      end\n    in aux l 0 0\nend\n"
        },
        {
            "description": "Using List.for_all with zipped pairs: Build a list of pairs of adjacent elements, then check for monotonicity using Quant.for_all.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.Combine\n  use list.Quant\n  use int.Int\n\n  let rec pairs (l: list int) : list (int, int) =\n    match l with\n    | Nil -> Nil\n    | Cons _ Nil -> Nil\n    | Cons x (Cons y tl) -> Cons (x, y) (pairs (Cons y tl))\n    end\n\n  let monotonic (l: list int) : bool =\n    let ps = pairs l in\n    (for_all (fun (x, y) -> x <= y) ps) || (for_all (fun (x, y) -> x >= y) ps)\nend\n"
        },
        {
            "description": "Early exit on non-monotonic pair: Traverse the list, and as soon as a violation is found, return false immediately (short-circuit).",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let monotonic (l: list int) : bool =\n    let rec aux (l: list int) (dir: int) : bool =\n      match l with\n      | Nil -> true\n      | Cons _ Nil -> true\n      | Cons x (Cons y tl) ->\n          if dir = 0 then\n            if x < y then aux (Cons y tl) 1\n            else if x > y then aux (Cons y tl) (-1)\n            else aux (Cons y tl) 0\n          else if dir = 1 then\n            if x > y then false else aux (Cons y tl) 1\n          else if dir = -1 then\n            if x < y then false else aux (Cons y tl) (-1)\n          else true\n      end\n    in aux l 0\nend\n"
        },
        {
            "description": "Check if list is sorted or reverse sorted: Use a helper to check if the list is sorted in increasing or decreasing order.",
            "implementation": "module HumanEval057\n  use list.List\n  use int.Int\n\n  let rec sorted (l: list int) (cmp: int -> int -> bool) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if cmp x y then sorted (Cons y tl) cmp else false\n    end\n\n  let monotonic (l: list int) : bool =\n    sorted l (<=) || sorted l (>=)\nend\n"
        },
        {
            "description": "Compare first and last elements to determine direction: Decide direction (increasing, decreasing, or constant) by comparing the first and last elements, then check accordingly.",
            "implementation": "module HumanEval057\n  use list.List\n  use list.HdTl\n  use int.Int\n\n  let rec last (l: list int) : int =\n    match l with\n    | Nil -> 0\n    | Cons x Nil -> x\n    | Cons _ tl -> last tl\n    end\n\n  let rec check (l: list int) (cmp: int -> int -> bool) : bool =\n    match l with\n    | Nil -> true\n    | Cons _ Nil -> true\n    | Cons x (Cons y tl) -> if cmp x y then check (Cons y tl) cmp else false\n    end\n\n  let monotonic (l: list int) : bool =\n    match l with\n    | Nil -> true\n    | Cons x _ ->\n      let y = last l in\n      if x < y then check l (<=)\n      else if x > y then check l (>=)\n      else check l (=)\n    end\nend\n"
        }
    ]
}