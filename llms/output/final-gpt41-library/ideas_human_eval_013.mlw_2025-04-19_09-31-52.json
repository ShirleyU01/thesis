{
    "ideas": [
        {
            "description": "Classic recursive Euclidean algorithm. If b == 0, return abs(a), else recurse with (b, a mod b).",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.EuclideanDivision\n\n  let rec greatest_common_divisor (a:int) (b:int) : int =\n    if b = 0 then abs a else greatest_common_divisor b (a mod b)\nend"
        },
        {
            "description": "Iterative Euclidean algorithm using a while loop and mutable variables.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.EuclideanDivision\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    var x = abs a in\n    var y = abs b in\n    while y <> 0 do\n      let r = x mod y in\n      x <- y;\n      y <- r\n    done;\n    x\nend"
        },
        {
            "description": "Recursive subtraction-based GCD (Stein's algorithm but without bit operations).",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n\n  let rec greatest_common_divisor (a:int) (b:int) : int =\n    let x = abs a in\n    let y = abs b in\n    if x = 0 then y\n    else if y = 0 then x\n    else if x > y then greatest_common_divisor (x - y) y\n    else greatest_common_divisor x (y - x)\nend"
        },
        {
            "description": "Iterative subtraction-based GCD algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    var x = abs a in\n    var y = abs b in\n    while x <> y do\n      if x > y then x <- x - y else y <- y - x\n    done;\n    x\nend"
        },
        {
            "description": "Use Why3's for loop to search from min(abs(a), abs(b)) down to 1 and return the largest divisor.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use int.EuclideanDivision\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    var res = 1 in\n    for d = m downto 1 do\n      if x mod d = 0 && y mod d = 0 then res <- d\n    done;\n    res\nend"
        },
        {
            "description": "Stein's binary GCD algorithm (using only even/odd checks and shifts).",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.EuclideanDivision\n\n  let rec is_even (n:int) : bool = (n mod 2 = 0)\n  let rec binary_gcd (a:int) (b:int) : int =\n    if a = b then a\n    else if a = 0 then b\n    else if b = 0 then a\n    else if is_even a && is_even b then 2 * binary_gcd (a div 2) (b div 2)\n    else if is_even a then binary_gcd (a div 2) b\n    else if is_even b then binary_gcd a (b div 2)\n    else if a > b then binary_gcd ((a - b) div 2) b\n    else binary_gcd ((b - a) div 2) a\n\n  let greatest_common_divisor (a:int) (b:int) : int = binary_gcd (abs a) (abs b)\nend"
        },
        {
            "description": "GCD using Why3's numof: count all divisors of both and pick the max.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use int.EuclideanDivision\n  use int.NumOf\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    let x = abs a in\n    let y = abs b in\n    let m = min x y in\n    var res = 1 in\n    for d = 1 to m do\n      if x mod d = 0 && y mod d = 0 then res <- d\n    done;\n    res\nend"
        },
        {
            "description": "Recursive wrapper normalizing negative inputs, then Euclidean algorithm.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.EuclideanDivision\n\n  let rec gcd_pos (a:int) (b:int) : int =\n    if b = 0 then a else gcd_pos b (a mod b)\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    gcd_pos (abs a) (abs b)\nend"
        },
        {
            "description": "Iterative Euclidean algorithm using Why3's min/max to optimize the order of arguments.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use int.EuclideanDivision\n\n  let greatest_common_divisor (a:int) (b:int) : int =\n    var x = abs a in\n    var y = abs b in\n    x <- max x y;\n    y <- min x y;\n    while y <> 0 do\n      let r = x mod y in\n      x <- y;\n      y <- r\n    done;\n    x\nend"
        },
        {
            "description": "Recursive Euclidean algorithm with swapping so the smaller argument is always second.",
            "implementation": "module HumanEval013\n  use int.Int\n  use int.Abs\n  use int.MinMax\n  use int.EuclideanDivision\n\n  let rec greatest_common_divisor (a:int) (b:int) : int =\n    let x = abs a in\n    let y = abs b in\n    if y = 0 then x\n    else if x < y then greatest_common_divisor y x\n    else greatest_common_divisor y (x mod y)\nend"
        }
    ]
}