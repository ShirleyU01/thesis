{
    "ideas": [
        {
            "description": "Using a for-loop to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Length\n    use list.Append\n\n    let rolling_max_for (t : list int) : list int =\n        let n = length t in\n        let ref max = nth 0 t in\n        let ref result = Cons max Nil in\n        for i = 1 to n-1 do\n            let current = nth i t in\n            if current > max then max <- current;\n            result <- append result (Cons max Nil)\n        done;\n        result\n\nend"
        },
        {
            "description": "Using a while-loop to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Length\n    use list.Append\n\n    let rolling_max_while (t : list int) : list int =\n        let n = length t in\n        let ref i = 0 in\n        let ref max = nth 0 t in\n        let ref result = Cons max Nil in\n        while i < n do\n            let current = nth i t in\n            if current > max then max <- current;\n            if i > 0 then result <- append result (Cons max Nil);\n            i <- i + 1\n        done;\n        result\n\nend"
        },
        {
            "description": "Using recursion with pattern matching to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n\n    let rec rolling_max_recur_1 (t : list int) (current_max : int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> let new_max = max current_max x in\n                       Cons new_max (rolling_max_recur_1 xs new_max)\n        end\n\n    let rolling_max (t : list int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> rolling_max_recur_1 xs x\n        end\n\nend"
        },
        {
            "description": "Using recursion with an accumulator to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n\n    let rec rolling_max_recur_2_accumulator (t : list int) (accumulator : list int) (current_max : int) : list int =\n        match t with\n        | Nil -> accumulator\n        | Cons x xs -> let new_max = max current_max x in\n                       rolling_max_recur_2_accumulator xs (append accumulator (Cons new_max Nil)) new_max\n        end\n\n    let rolling_max (t : list int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> rolling_max_recur_2_accumulator xs (Cons x Nil) x\n        end\n\nend"
        },
        {
            "description": "Using recursion with if-then-else branching to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n\n    let rec rolling_max_recur_3 (t : list int) (current_max : int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> let new_max = if x > current_max then x else current_max in\n                       Cons new_max (rolling_max_recur_3 xs new_max)\n        end\n\n    let rolling_max (t : list int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> rolling_max_recur_3 xs x\n        end\n\nend"
        },
        {
            "description": "Using fold_left to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.FoldLeft\n\n    let rolling_max_fold (t : list int) : list int =\n        let folder acc x =\n            match acc with\n            | Nil -> Cons x Nil\n            | Cons last_max rest -> let new_max = max last_max x in\n                                    append acc (Cons new_max Nil)\n            end\n        in\n        fold_left folder Nil t\n\nend"
        },
        {
            "description": "Using a functional approach with map to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Map\n\n    let rolling_max_map (t : list int) : list int =\n        let ref max = nth 0 t in\n        map (fun x -> let new_max = max max x in\n                      if new_max > max then max <- new_max;\n                      max) t\n\nend"
        },
        {
            "description": "Using tail-recursion with an accumulator to accumulate rolling maximums",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n\n    let rec rolling_max_tail_recur (t : list int) (accumulator : list int) (current_max : int) : list int =\n        match t with\n        | Nil -> accumulator\n        | Cons x xs -> let new_max = max current_max x in\n                       rolling_max_tail_recur xs (append accumulator (Cons new_max Nil)) new_max\n        end\n\n    let rolling_max (t : list int) : list int =\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> rolling_max_tail_recur xs (Cons x Nil) x\n        end\n\nend"
        },
        {
            "description": "Using nested recursion for inner maximum calculation",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n    use list.Reverse\n\n    let rec max_until_index (t : list int) (index : int) : int =\n        match t with\n        | Nil -> -1000\n        | Cons x xs -> if index = 0 then x else max x (max_until_index xs (index - 1))\n        end\n\n    let rolling_max_nested_recur (t : list int) : list int =\n        let n = length t in\n        let rec build_result (i : int) (acc : list int) : list int =\n            if i >= n then acc\n            else\n                let max_at_i = max_until_index t i in\n                build_result (i + 1) (append acc (Cons max_at_i Nil))\n        in\n        build_result 0 Nil\n\nend"
        },
        {
            "description": "Using list comprehension style via map and recursion",
            "implementation": "module RollingMax\n\n    use int.Int\n    use list.List\n    use list.Append\n    use list.Map\n\n    let rolling_max_list_comp (t : list int) : list int =\n        let rec max_until (lst : list int) (acc : list int) (current_max : int) : list int =\n            match lst with\n            | Nil -> acc\n            | Cons x xs -> let new_max = max current_max x in\n                           max_until xs (append acc (Cons new_max Nil)) new_max\n            end\n        in\n        match t with\n        | Nil -> Nil\n        | Cons x xs -> max_until xs (Cons x Nil) x\n        end\n\nend"
        }
    ]
}