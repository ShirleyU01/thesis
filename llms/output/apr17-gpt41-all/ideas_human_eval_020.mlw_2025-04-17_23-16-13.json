{
    "ideas": [
        {
            "description": "Iterative with two nested for-loops using indices (find all pairs, compute abs difference, track minimum).",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with \n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref res1 = nth_my 0 numbers in\n    let ref res2 = nth_my 1 numbers in\n    for i = 0 to n-1 do\n      for j = i+1 to n-1 do\n        let x = nth_my i numbers in\n        let y = nth_my j numbers in\n        let diff = abs (x-y) in\n        if diff < min_diff then begin\n          min_diff <- diff; \n          if x < y then (res1 <- x; res2 <- y) else (res1 <- y; res2 <- x)\n        end\n      done\n    done ;\n    Cons res1 (Cons res2 Nil)\nend"
        },
        {
            "description": "Sort the list, then scan adjacent pairs for minimum difference (single pass).",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.SortedInt\n  use list.Map\n\n  (* Insertion sort for int list *)\n  let rec insert (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert x ys)\n    end\n\n  let rec sort (l:list int) : list int =\n    match l with | Nil -> Nil | Cons x xs -> insert x (sort xs) end\n\n  let rec find_pair_adj (l: list int) (cur_min: int) (cur_x: int) (cur_y: int) : (int, int) =\n    match l with\n    | Cons x (Cons y ys) -> let diff = abs (x-y) in\n        if diff < cur_min then find_pair_adj (Cons y ys) diff x y\n        else find_pair_adj (Cons y ys) cur_min cur_x cur_y\n    | _ -> (cur_x, cur_y)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    let x0 = nth_my 0 sorted in\n    let x1 = nth_my 1 sorted in\n    let (a, b) = find_pair_adj sorted (abs (x0-x1)) x0 x1 in\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Use recursion with accumulator to keep track of minimum difference and the pair found so far. Checks all pairs.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec check_pairs (l: list int) (cur_min: int) (cur_a: int) (cur_b: int) : (int, int) =\n    match l with\n    | Nil -> (cur_a, cur_b)\n    | Cons x xs ->\n        let rec check_rest (l2: list int) (min_d: int) (min_a: int) (min_b: int) : (int, int) =\n          match l2 with\n          | Nil -> (min_a, min_b)\n          | Cons y ys -> let d = abs (x - y) in\n            if d < min_d then check_rest ys d (min x y) (max x y)\n            else check_rest ys min_d min_a min_b\n          end\n        in\n        let (m_a, m_b) = check_rest xs cur_min cur_a cur_b in\n        check_pairs xs (abs (m_a - m_b)) m_a m_b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = check_pairs (Cons x (Cons y xs)) (abs (x-y)) (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Recursive approach: for each element, compare to every other element (helper function), update minimum pair.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec helper (x:int) (l:list int) (cur_min:int) (cur_a:int) (cur_b:int) : (int, int, int) =\n    match l with\n    | Nil -> (cur_min, cur_a, cur_b)\n    | Cons y ys ->\n      let d = abs (x-y) in\n      if d < cur_min then helper x ys d (min x y) (max x y)\n      else helper x ys cur_min cur_a cur_b\n    end\n\n  let rec outer (l:list int) (cur_min:int) (cur_a:int) (cur_b:int) : (int, int) =\n    match l with\n    | Nil -> (cur_a, cur_b)\n    | Cons x xs ->\n      let (d, a, b) = helper x xs cur_min cur_a cur_b in\n      outer xs d a b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (a, b) = outer (Cons x (Cons y xs)) (abs (x-y)) (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Iterate using a while-loop with index pointers, compare all pairs (imperative style).",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with | Cons x r -> if n = 0 then x else nth_my (n-1) r end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref i = 0 in\n    let ref min_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref res1 = nth_my 0 numbers in\n    let ref res2 = nth_my 1 numbers in\n    while i < n do\n      let ref j = i + 1 in\n      while j < n do\n        let x = nth_my i numbers in\n        let y = nth_my j numbers in\n        let diff = abs (x-y) in\n        if diff < min_diff then begin\n          min_diff <- diff;\n          if x < y then (res1 <- x; res2 <- y) else (res1 <- y; res2 <- x)\n        end;\n        j <- j + 1\n      done;\n      i <- i + 1\n    done;\n    Cons res1 (Cons res2 Nil)\nend"
        },
        {
            "description": "Divide-and-conquer style: split list, solve for halves, check across boundary. (Brute-force for cross, for small input.)",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Prefix\n  use list.Reverse\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with | Cons x r -> if n = 0 then x else nth_my (n-1) r end\n\n  let rec find_min_pair (l: list int) : (int, int, int) =\n    let n = length l in\n    if n <= 1 then (1000000, 0, 0) else\n    let ref min_d = abs (nth_my 0 l - nth_my 1 l) in\n    let ref a = nth_my 0 l in\n    let ref b = nth_my 1 l in\n    for i = 0 to n-1 do for j = i+1 to n-1 do\n      let x = nth_my i l in\n      let y = nth_my j l in\n      let d = abs (x-y) in\n      if d < min_d then begin min_d <- d; a <- min x y; b <- max x y end\n    done done;\n    (min_d, a, b)\n\n  let rec find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    if n < 2 then Nil else\n    let k = n/2 in\n    let left = Prefix.prefix k numbers in\n    let right = Prefix.prefix (n-k) (Reverse.reverse left) in\n    let (d1, a1, b1) = find_min_pair left in\n    let (d2, a2, b2) = find_min_pair right in\n    let (d3, a3, b3) = find_min_pair numbers in\n    let min_d = min (min d1 d2) d3 in\n    if min_d = d1 then Cons a1 (Cons b1 Nil)\n    else if min_d = d2 then Cons a2 (Cons b2 Nil)\n    else Cons a3 (Cons b3 Nil)\nend"
        },
        {
            "description": "Single-pass, maintaining running minimum and pair by scanning all pairs but skipping duplicates.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec process (l: list int) (min_d: int) (min_a: int) (min_b: int) : (int, int, int) =\n    match l with\n    | Nil -> (min_d, min_a, min_b)\n    | Cons x xs ->\n      let rec inner (l2: list int) (cur_min: int) (cur_a: int) (cur_b: int) : (int, int, int) =\n        match l2 with\n        | Nil -> (cur_min, cur_a, cur_b)\n        | Cons y ys ->\n          let d = abs (x-y) in\n          if d < cur_min then inner ys d (min x y) (max x y)\n          else inner ys cur_min cur_a cur_b\n        end\n      in\n      let (new_min_d, new_a, new_b) = inner xs min_d min_a min_b in\n      process xs new_min_d new_a new_b\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    match numbers with\n    | Cons x (Cons y xs) ->\n      let (d, a, b) = process (Cons x (Cons y xs)) (abs (x-y)) (min x y) (max x y) in\n      Cons a (Cons b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Sort, then use fold_left to find the pair of adjacent elements with the smallest difference.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Map\n  use list.FoldLeft\n\n  let rec insert (x:int) (l:list int) : list int =\n    match l with\n    | Nil -> Cons x Nil\n    | Cons y ys -> if x <= y then Cons x l else Cons y (insert x ys)\n    end\n\n  let rec sort (l:list int) : list int =\n    match l with | Nil -> Nil | Cons x xs -> insert x (sort xs) end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let sorted = sort numbers in\n    match sorted with\n    | Cons x (Cons y xs) ->\n      let f ((min_d, min_a, min_b): (int, int, int)) (z:int) : (int, int, int) =\n        let d = abs (z - min_b) in\n        if d < min_d then (d, min min_b z, max min_b z) else (min_d, min_a, min_b)\n      in\n      let (best_d, best_a, best_b) = fold_left f (abs (x-y), x, y) xs in\n      Cons best_a (Cons best_b Nil)\n    | _ -> Nil\n    end\nend"
        },
        {
            "description": "Enumerate all pairs using a helper that converts the list to an array for index-based pair comparison.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n:int) (l:list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    match l with | Cons x r -> if n = 0 then x else nth_my (n-1) r end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let n = length numbers in\n    let ref min_d = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref a = nth_my 0 numbers in\n    let ref b = nth_my 1 numbers in\n    for i = 0 to n-1 do\n      for j = 0 to n-1 do\n        if i <> j then\n          let x = nth_my i numbers in\n          let y = nth_my j numbers in\n          let d = abs (x-y) in\n          if d < min_d then begin a <- min x y; b <- max x y; min_d <- d end\n      done\n    done;\n    Cons a (Cons b Nil)\nend"
        },
        {
            "description": "Pairwise recursive compare by removing head and finding closest between head and rest, and among the rest.",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n\n  let rec closest_to_head (x:int) (l:list int) (min_d:int) (min_a:int) (min_b:int) : (int, int, int) =\n    match l with\n    | Nil -> (min_d, min_a, min_b)\n    | Cons y ys ->\n      let d = abs (x-y) in\n      if d < min_d then closest_to_head x ys d (min x y) (max x y)\n      else closest_to_head x ys min_d min_a min_b\n    end\n\n  let rec find_pair (l: list int) : (int, int, int) =\n    match l with\n    | Cons x xs ->\n      let (d1, a1, b1) = closest_to_head x xs 1000000 0 0 in\n      let (d2, a2, b2) = find_pair xs in\n      if d1 < d2 then (d1, a1, b1) else (d2, a2, b2)\n    | Nil -> (1000000, 0, 0)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    let (d, a, b) = find_pair numbers in\n    Cons a (Cons b Nil)\nend"
        }
    ]
}