{
    "ideas": [
        {
            "description": "Using trial division method with a for-loop iterating up to the square root of n.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\nuse int.Fact\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false else\n    let rec check (i: int) : bool =\n      if i * i > n then true else\n        if mod n i = 0 then false else check (i + 1)\n    in check 2\nend\n"
        },
        {
            "description": "Using a recursive function to check divisibility only up to the square root of n.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet rec is_prime_rec (n: int) (i: int) : bool =\n  if i * i > n then true\n  else if mod n i = 0 then false\n  else is_prime_rec n (i + 1)\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else is_prime_rec n 2\nend\n"
        },
        {
            "description": "Using pattern matching and recursive division check.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet rec check_division (n: int) (i: int) : bool =\n  match i * i > n with\n  | true -> true\n  | false -> if mod n i = 0 then false else check_division n (i + 1)\n  end\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else check_division n 2\nend\n"
        },
        {
            "description": "Using an accumulator in a recursive function to track division results.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet rec check_prime (n: int) (i: int) (acc: bool) : bool =\n  if not acc then false\n  else if i * i > n then true\n  else check_prime n (i + 1) (acc && mod n i <> 0)\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else check_prime n 2 true\nend\n"
        },
        {
            "description": "Utilizing a while-loop to perform trial division.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else let ref i = 2 in\n  let ref is_prime = true in\n  while i * i <= n && is_prime do\n    if mod n i = 0 then is_prime <- false;\n    i <- i + 1\n  done;\n  is_prime\nend\n"
        },
        {
            "description": "Using for-loop with constraints to check non-divisibility.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else begin\n    let ref is_prime = true in\n    for i = 2 to n div 2 do\n      if mod n i = 0 then is_prime <- false\n    done;\n    is_prime\n  end\nend\n"
        },
        {
            "description": "Prime check using recursion and logical conjunctions for divisibility tests.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet rec check_prime (n: int) (i: int) : bool =\n  if i * i > n then true\n  else (mod n i <> 0) && check_prime n (i + 1)\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else check_prime n 2\nend\n"
        },
        {
            "description": "Using pattern matching with guards for prime determination.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet rec is_prime_match (n: int) (i: int) : bool =\n  match i * i > n with\n  | true -> true\n  | false when mod n i = 0 -> false\n  | false -> is_prime_match n (i + 1)\n  end\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else is_prime_match n 2\nend\n"
        },
        {
            "description": "Using a list of potential divisors up to the square root of n.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\nuse list.List\nuse list.Length\n\nlet rec generate_list (limit: int) : list int =\n  if limit < 2 then Nil else Cons limit (generate_list (limit - 1))\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else\n    let rec check_list (lst: list int) : bool =\n      match lst with\n      | Nil -> true\n      | Cons x xs -> if mod n x = 0 then false else check_list xs\n      end\n    in check_list (generate_list (n div 2))\nend\n"
        },
        {
            "description": "Using a precomputed small primes list for initial checks before trial division.",
            "implementation": "\nmodule HumanEval031\n\nuse int.Int\nuse int.EuclideanDivision\n\nlet small_primes = Cons 2 (Cons 3 (Cons 5 (Cons 7 Nil)))\n\nlet rec is_divisible_by_any (n: int) (lst: list int) : bool =\n  match lst with\n  | Nil -> false\n  | Cons x xs -> (mod n x = 0) || is_divisible_by_any n xs\n  end\n\nlet is_prime (n: int) : bool =\n  if n < 2 then false\n  else if is_divisible_by_any n small_primes then false\n  else\n    let rec check_division (i: int) : bool =\n      if i * i > n then true\n      else if mod n i = 0 then false\n      else check_division (i + 2)\n    in check_division 11\nend\n"
        }
    ]
}