{
    "ideas": [
        {
            "description": "Naive nested for\u2010loops: scan every pair (i,j) tracking minimum absolute difference",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let ref best_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref best_i = 0 in\n    let ref best_j = 1 in\n    for i = 0 to n - 2 do\n      for j = i + 1 to n - 1 do\n        let d = abs (nth_my i numbers - nth_my j numbers) in\n        if d < !best_diff then\n          best_diff <- d;\n          best_i <- i;\n          best_j <- j\n        end\n      done\n    done;\n    let a = nth_my best_i numbers in\n    let b = nth_my best_j numbers in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Imperative nested while\u2010loops: two counters i, j updated in while",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let ref best_diff = abs (nth_my 0 numbers - nth_my 1 numbers) in\n    let ref best_i = 0 in\n    let ref best_j = 1 in\n    let ref i = 0 in\n    while i < n - 1 do\n      let ref j = i + 1 in\n      while j < n do\n        let d = abs (nth_my !i numbers - nth_my !j numbers) in\n        if d < !best_diff then\n          best_diff <- d;\n          best_i <- !i;\n          best_j <- !j\n        end;\n        j <- !j + 1\n      done;\n      i <- !i + 1\n    done;\n    let a = nth_my best_i numbers in\n    let b = nth_my best_j numbers in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Pure nested recursion (outer/inner) with accumulators, no loops",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec inner (i: int) (j: int) (n: int) (nums: list int)\n      (best_diff: int) (best_pair: int * int) : int * (int * int) =\n    requires { j <= n }\n    variant { n - j }\n    match j < n with\n    | True ->\n        let x = nth_my i nums in\n        let y = nth_my j nums in\n        let d = abs (x - y) in\n        let (nd, np) = if d < best_diff then (d, (x, y)) else (best_diff, best_pair) in\n        inner i (j + 1) n nums nd np\n    | False -> (best_diff, best_pair)\n    end\n\n  let rec outer (i: int) (n: int) (nums: list int)\n      (best_diff: int) (best_pair: int * int) : int * (int * int) =\n    requires { i <= n }\n    variant { n - i }\n    match i < n - 1 with\n    | True ->\n        let (d', p') = inner i (i + 1) n nums best_diff best_pair in\n        outer (i + 1) n nums d' p'\n    | False -> (best_diff, best_pair)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let n = length numbers in\n    let x0 = nth_my 0 numbers in\n    let x1 = nth_my 1 numbers in\n    let (d, (a, b)) = outer 0 n numbers (abs (x0 - x1)) (x0, x1) in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Insertion\u2010sort then single\u2010pass scan of adjacent sorted list",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Append\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec insert x = function\n  | Nil -> Cons x Nil\n  | Cons y ys -> if x < y then Cons x (Cons y ys) else Cons y (insert x ys)\n  end\n\n  let rec isort = function\n  | Nil -> Nil\n  | Cons x xs -> insert x (isort xs)\n  end\n\n  let rec scan = function\n  | Cons x (Cons y ys) ->\n      let d = abs (x - y) in\n      let (r1, r2, rd) = scan ys in (* returns best pair and diff so far *)\n      if rd < d then (r1, r2, rd) else (x, y, d)\n  | _ -> (0,0, max_int) (* unreachable for length>=2 *)\n  end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = isort numbers in\n    let (a, b, _) = scan sorted in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Quicksort then scan adjacent: a different sorting algorithm",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Append\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec filter_lt pivot = function\n  | Nil -> Nil\n  | Cons x xs -> if x < pivot then Cons x (filter_lt pivot xs) else filter_lt pivot xs\n  end\n\n  let rec filter_ge pivot = function\n  | Nil -> Nil\n  | Cons x xs -> if x >= pivot then Cons x (filter_ge pivot xs) else filter_ge pivot xs\n  end\n\n  let rec qsort = function\n  | Nil -> Nil\n  | Cons x xs ->\n      let less = qsort (filter_lt x xs) in\n      let greater = qsort (filter_ge x xs) in\n      less ++ Cons x Nil ++ greater\n  end\n\n  let rec scan_adj = function\n  | Cons x (Cons y ys) ->\n      let d = abs (x - y) in\n      let (r1, r2, rd) = scan_adj ys in\n      if rd < d then (r1, r2, rd) else (x, y, d)\n  | _ -> (0,0, max_int)\n  end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = qsort numbers in\n    let (a,b,_) = scan_adj sorted in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Two\u2010pass: first find the minimum element then find the element closest to it",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec find_min l =\n    match l with\n    | Cons x Nil -> x\n    | Cons x xs -> let m = find_min xs in if x < m then x else m\n    end\n\n  let rec find_best l m best other =\n    match l with\n    | Cons x xs ->\n        let d = abs (x - m) in\n        if x <> m && d < best then find_best xs m d x else find_best xs m best other\n    | Nil -> (m, other)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let m = find_min numbers in\n    let (a,b) = find_best numbers m (max_int) m in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Generate all pairs list then scan for minimal diff",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Append\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec make_pairs_from x idx xs =\n    match xs with\n    | Cons y ys -> Cons (idx, idx+1) (make_pairs_from x (idx+1) ys)\n    | Nil -> Nil\n    end  (* returns list of (i,j) *)\n\n  let rec all_pairs i l =\n    match l with\n    | Cons _ Nil -> Nil\n    | Cons _ xs -> make_pairs_from () i xs ++ all_pairs (i+1) xs\n    | Nil -> Nil\n    end\n\n  let rec scan_pairs ps nums best_i best_j best_d =\n    match ps with\n    | Cons (i,j) qs ->\n        let x = nth_my i nums in let y = nth_my j nums in\n        let d = abs (x - y) in\n        if d < best_d then scan_pairs qs nums i j d else scan_pairs qs nums best_i best_j best_d\n    | Nil -> (best_i, best_j)\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let initial = (0,1) in\n    let (i,j) = scan_pairs (all_pairs 0 numbers) numbers (fst initial) (snd initial) (abs (nth_my 0 numbers - nth_my 1 numbers)) in\n    let a = nth_my i numbers in let b = nth_my j numbers in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Divide and conquer sort (merge sort) then scan adjacent",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Append\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec split = function\n  | Nil | Cons _ Nil as l -> (l, Nil)\n  | Cons x (Cons y ys) -> let (l1,l2) = split ys in (Cons x l1, Cons y l2)\n  end\n\n  let rec merge l1 l2 =\n    match (l1, l2) with\n    | Nil, _ -> l2\n    | _, Nil -> l1\n    | Cons x xs, Cons y ys -> if x < y then Cons x (merge xs l2) else Cons y (merge l1 ys)\n    end\n\n  let rec msort l =\n    match l with\n    | Nil | Cons _ Nil -> l\n    | _ -> let (a,b) = split l in merge (msort a) (msort b)\n    end\n\n  let rec scan_adj = function\n  | Cons x (Cons y ys) ->\n      let d = abs (x - y) in\n      let (r1,r2,rd) = scan_adj ys in if rd < d then (r1,r2,rd) else (x,y,d)\n  | _ -> (0,0, max_int)\n  end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = msort numbers in\n    let (a,b,_) = scan_adj sorted in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        },
        {
            "description": "Single\u2010pass on sorted list using combine with tail then scan",
            "implementation": "module HumanEval020\n  use int.Int\n  use int.Abs\n  use list.List\n  use list.Length\n  use list.Combine\n\n  let rec nth_my (n: int) (l: list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec insert x = function\n  | Nil -> Cons x Nil\n  | Cons y ys -> if x < y then Cons x (Cons y ys) else Cons y (insert x ys)\n  end\n  let rec isort = function\n  | Nil -> Nil\n  | Cons x xs -> insert x (isort xs)\n  end\n\n  let rec scan_pairs ps best =\n    match ps with\n    | Cons (x,y) qs ->\n        let d = abs (x - y) in\n        let (bx,by,bd) = best in\n        if d < bd then scan_pairs qs (x,y,d)\n        else scan_pairs qs best\n    | Nil -> best\n    end\n\n  let find_closest_elements (numbers: list int) : list int =\n    requires { length numbers >= 2 }\n    let sorted = isort numbers in\n    let tail =\n      match sorted with\n      | Cons _ xs -> xs\n      | Nil -> Nil\n      end in\n    let pairs = combine sorted tail in\n    let (a,b,_) = scan_pairs pairs (0,0,max_int) in\n    if a < b then Cons a (Cons b Nil) else Cons b (Cons a Nil)\nend"
        }
    ]
}