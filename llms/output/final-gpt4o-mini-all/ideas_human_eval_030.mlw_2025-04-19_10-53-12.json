{
    "ideas": [
        {
            "description": "Simple recursion with pattern matching: directly traverse the list, including x in the result if x>0.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n\n  let rec get_positive (l : list int) : list int =\n    match l with\n    | Nil -> Nil\n    | Cons x xs ->\n        if x > 0 then Cons x (get_positive xs)\n        else get_positive xs\n    end\nend"
        },
        {
            "description": "Tail\u2011recursive with accumulator and final reverse: collect positives in reverse order, then reverse to restore original order.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Reverse\n\n  let rec aux (l acc : list int) : list int =\n    match l with\n    | Nil -> rev acc\n    | Cons x xs ->\n        if x > 0 then aux xs (Cons x acc)\n        else aux xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    aux l Nil\nend"
        },
        {
            "description": "Tail\u2011recursive with accumulator and rev_append to append each positive at the end without a final reverse.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.RevAppend\n\n  let rec aux (l acc : list int) : list int =\n    match l with\n    | Nil -> acc\n    | Cons x xs ->\n        if x > 0 then aux xs (rev_append (Cons x Nil) acc)\n        else aux xs acc\n    end\n\n  let get_positive (l : list int) : list int =\n    aux l Nil\nend"
        },
        {
            "description": "For\u2011loop with nth_my: iterate indices, build reversed accumulator, then reverse at end.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Reverse\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref acc = Nil in\n    for i = 0 to n - 1 do\n      let x = nth_my i l in\n      if x > 0 then acc <- Cons x acc\n    done;\n    rev acc\nend"
        },
        {
            "description": "For\u2011loop with nth_my and rev_append: iterate indices, append positives in correct order using rev_append, no final reverse.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.RevAppend\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref acc = Nil in\n    for i = 0 to n - 1 do\n      let x = nth_my i l in\n      if x > 0 then acc <- rev_append (Cons x Nil) acc\n    done;\n    acc\nend"
        },
        {
            "description": "While\u2011loop with nth_my: same as for\u2011loop but using a while and a mutable index and accumulator.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n  use list.Reverse\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let get_positive (l : list int) : list int =\n    let n = length l in\n    let ref i = 0 in\n    let ref acc = Nil in\n    while i < n do\n      let x = nth_my i l in\n      if x > 0 then acc <- Cons x acc;\n      i <- i + 1\n    done;\n    rev acc\nend"
        },
        {
            "description": "While\u2011loop with hd/tl: walk the list using hd and tl, accumulate in reverse, then reverse at end.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.HdTl\n  use list.Reverse\n\n  let get_positive (l : list int) : list int =\n    let ref acc = Nil in\n    let ref cur = l in\n    while not (is_nil cur) do\n      match hd cur with\n      | Some x ->\n          if x > 0 then acc <- Cons x acc;\n          (match tl cur with Some xs -> cur <- xs | None -> cur <- Nil)\n      end\n    done;\n    rev acc\nend"
        },
        {
            "description": "Index\u2011based recursion with nth_my: define aux(i) that checks nth_my(i) and recurses, building final result.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Length\n  use list.NthNoOpt\n\n  let rec nth_my (n : int) (l : list int) : int =\n    requires { length l > 0 }\n    requires { 0 <= n /\\ n < length l }\n    variant { n }\n    ensures { nth n l = result }\n    match l with\n    | Cons x r -> if n = 0 then x else nth_my (n - 1) r\n    end\n\n  let rec aux (i : int) (n : int) (l0 : list int) : list int =\n    if i >= n then Nil\n    else\n      let x = nth_my i l0 in\n      if x > 0 then Cons x (aux (i + 1) n l0) else aux (i + 1) n l0\n\n  let get_positive (l : list int) : list int =\n    aux 0 (length l) l\nend"
        },
        {
            "description": "Double reverse: reverse input, filter by simple recursion, then reverse result to restore order.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.Reverse\n\n  let get_positive (l : list int) : list int =\n    let rl = rev l in\n    let rec f (l' : list int) : list int =\n      match l' with\n      | Nil -> Nil\n      | Cons x xs -> if x > 0 then Cons x (f xs) else f xs\n      end in\n    rev (f rl)\nend"
        },
        {
            "description": "Partition\u2011style: accumulate positives and negatives separately, then return reversed positives.",
            "implementation": "module HumanEval030\n  use int.Int\n  use list.List\n  use list.RevAppend\n  use list.Reverse\n\n  let rec part (l pos neg : list int) : list int =\n    match l with\n    | Nil -> rev pos\n    | Cons x xs ->\n        if x > 0 then part xs (Cons x pos) neg\n        else part xs pos (Cons x neg)\n    end\n\n  let get_positive (l : list int) : list int =\n    part l Nil Nil\nend"
        }
    ]
}