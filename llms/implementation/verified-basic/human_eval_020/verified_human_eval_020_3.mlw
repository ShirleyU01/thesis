module HumanEval020
  use int.Int
  use int.Abs
  use int.MinMax
  use list.List
  use list.Length
  use list.Mem
  use list.NthNoOpt

  predicate sorted (l: list int) =
    match l with
    | Nil -> true
    | Cons x Nil -> true
    | Cons x (Cons y ys) -> x <= y /\ sorted (Cons y ys)
    end

  predicate adjacent_closest_pair (l: list int) (a:int) (b:int) =
    let rec aux (l: list int) (min_diff: int) (a:int) (b:int) : bool =
      match l with
      | Cons x (Cons y ys) ->
          let d = abs (x - y) in
          if d < min_diff then aux (Cons y ys) d x y
          else aux (Cons y ys) min_diff a b
      | _ -> true
      end
    in
    match l with
    | Cons x (Cons y xs) ->
        let min_diff = abs (x - y) in
        let rec check (l: list int) (cur_min: int) (a0:int) (b0:int) : bool =
          match l with
          | Cons x1 (Cons x2 xs1) ->
              let d = abs (x1 - x2) in
              if d < cur_min then check (Cons x2 xs1) d x1 x2
              else check (Cons x2 xs1) cur_min a0 b0
          | _ -> a0 = a /\ b0 = b
          end
        in
        check (Cons x (Cons y xs)) min_diff x y
    | _ -> false
    end

  predicate exists_adjacent_pair_with_diff (l: list int) (d: int) =
    match l with
    | Cons x (Cons y xs) ->
        abs (x - y) = d \/ exists_adjacent_pair_with_diff (Cons y xs) d
    | _ -> false
    end

  (* insert x into a sorted list l, result is sorted and a permutation *)
  let rec insert (x:int) (l:list int) : list int
    ensures { sorted l -> sorted result }
    ensures { mem x result }
    ensures { forall y. mem y l -> mem y result }
    ensures { forall y. mem y result -> y = x \/ mem y l }
    variant { l }
  = match l with
    | Nil -> Cons x Nil
    | Cons y ys -> if x < y then Cons x l else Cons y (insert x ys)
    end

  (* standard insertion sort: result is sorted, a permutation, and same length *)
  let rec sort (l:list int) : list int
    ensures { length result = length l }
    ensures { sorted result }
    ensures { forall x. mem x l <-> mem x result }
    variant { l }
  = match l with
    | Nil -> Nil
    | Cons x xs -> insert x (sort xs)
    end

  (* Find the adjacent pair with minimal diff, in a sorted list l *)
  let rec closest_adjacent (l:list int) (min_diff: int) (a:int) (b:int) : (int, int)
    requires { sorted l }
    requires { length l >= 2 }
    requires { exists_adjacent_pair_with_diff l min_diff }
    ensures {
      let (a0, b0) = result in
      exists_adjacent_pair_with_diff l (abs (a0 - b0)) /\
      forall x y. (adjacent l x y -> abs (x-y) >= abs (a0-b0))
    }
    variant { length l }
  = match l with
    | Cons x (Cons y ys) ->
      let d = abs (x - y) in
      if d < min_diff then closest_adjacent (Cons y ys) d x y else closest_adjacent (Cons y ys) min_diff a b
    | _ -> (a, b)
    end

  predicate adjacent (l: list int) (a:int) (b:int) =
    match l with
    | Cons x (Cons y xs) -> (x = a /\ y = b) \/ adjacent (Cons y xs) a b
    | _ -> false
    end

  (* Main function: returns two closest elements in order (smaller, larger), or Nil if <2 elements *)
  let find_closest_elements (numbers: list int) : list int
    ensures {
      length numbers < 2 -> result = Nil
    }
    ensures {
      length numbers >= 2 ->
        length result = 2 /\
        let a = nth result 0 in
        let b = nth result 1 in
        a <= b /\
        mem a numbers /\ mem b numbers /\
        a <= b /\
        forall i j. i <> j /\ 0 <= i < length numbers /\ 0 <= j < length numbers -> abs (nth numbers i - nth numbers j) >= abs (a-b)
    }
  =
    match sort numbers with
    | Cons x (Cons y xs) ->
      let (a, b) = closest_adjacent (Cons x (Cons y xs)) (abs (x - y)) x y in
      if a <= b then Cons a (Cons b Nil)
      else Cons b (Cons a Nil)
    | _ -> Nil
    end
end
