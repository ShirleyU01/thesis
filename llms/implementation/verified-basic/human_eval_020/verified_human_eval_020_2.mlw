module HumanEval020
  use int.Int
  use int.Abs
  use int.MinMax
  use list.List
  use list.Length
  use list.Mem
  use list.NthNoOpt

  (* Helper to check that the two elements a and b really exist in the input list *)
  predicate elements_in_list (a: int) (b: int) (l: list int) =
    mem a l /\ mem b l

  (* Loop invariant for find_closest_helper:  
     - best is the smallest difference found so far
     - (a, b) are two numbers from the original list with that difference *)
  let rec find_closest_helper (l: list int) (current: int) (best: int) (a: int) (b: int) : (int, int, int)
    requires { length l >= 0 }
    requires { mem current (Cons current l) }
    requires { best >= 0 }
    requires { elements_in_list a b (Cons current l) }
    variant  { length l }
    ensures  { let (r_best, r_a, r_b) = result in
                r_best >= 0 /\
                elements_in_list r_a r_b (Cons current l) /\
                (forall i j. mem i (Cons current l) /\ mem j (Cons current l) -> abs (i-j) >= r_best)
              }
    =
    match l with
    | Nil -> (best, a, b)
    | Cons x xs ->
      let d = abs (x - current) in
      if d < best then find_closest_helper xs current d (min x current) (max x current)
      else find_closest_helper xs current best a b
    end

  (*
    Invariant: at each step, (a,b) are from the suffix list, best is their distance, and best is minimal for all examined pairs so far
   *)
  let rec aux (l: list int) (best: int) (a: int) (b: int) : (int, int)
    requires { length l >= 2 }
    requires { best >= 0 }
    requires { elements_in_list a b l }
    variant  { length l }
    ensures  { let (out_a, out_b) = result in
                elements_in_list out_a out_b l /\
                (forall i j. mem i l /\ mem j l -> abs (i-j) >= abs (out_a - out_b))
              }
    =
    match l with
    | Nil -> (a, b)
    | Cons x xs ->
      let (new_best, new_a, new_b) = find_closest_helper xs x best a b in
      aux xs new_best new_a new_b
    end

  (*
    Precondition: list has at least two elements. 
    Postcondition: result is a list of length 2 containing the closest pair (in sorted order).
   *)
  let find_closest_elements (numbers: list int) : list int =
    requires { length numbers >= 2 }
    ensures { length result = 2 }
    ensures { forall x y. (mem x numbers /\ mem y numbers) -> abs (x-y) >= abs (nth 0 result - nth 1 result) }
    ensures { nth 0 result <= nth 1 result }
    ensures { mem (nth 0 result) numbers /\ mem (nth 1 result) numbers }
    match numbers with
    | Cons x (Cons y xs) ->
      let first_diff = abs (x - y) in
      let (a, b) = aux numbers first_diff (min x y) (max x y) in
      Cons a (Cons b Nil)
    | _ -> Nil
    end
end
