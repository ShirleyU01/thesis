module HumanEval085
  use int.Int
  use int.EuclideanDivision
  use list.List

  function spec_add (l : list int) : int =
    match l with
    | Cons _ (Cons y ys) ->
        (if mod y 2 = 0 then y else 0) + spec_add ys
    | _ -> 0
    end

  predicate even (x:int) = mod x 2 = 0
  predicate odd (x:int) = mod x 2 = 1

  (* zip_index puts indices starting from i on each element *)
  let rec zip_index (l : list int) (i : int) : list (int, int)
    variant { length l }
    ensures { forall j:int, x:int. 0 <= j < length l ->
      nth (zip_index l i) j = (i + j, nth l j)
    }
    ensures { length result = length l }
  =
    match l with
    | Nil -> Nil
    | Cons x xs -> Cons (i, x) (zip_index xs (i + 1))
    end

  (* add_zip adds up x where index is odd and x is even *)
  let rec add_zip (l : list (int, int)) : int
    variant { length l }
    ensures { result = (
      let rec sum (l:list (int,int)) : int =
        match l with
        | Nil -> 0
        | Cons (i, x) xs -> (if odd i && even x then x else 0) + sum xs
        end
      in sum l)
    }
  =
    match l with
    | Nil -> 0
    | Cons (i, x) xs ->
        let s = add_zip xs in
        if mod i 2 = 1 && mod x 2 = 0 then x + s else s
    end

  (*
     Lemma: For all l, spec_add l = add_zip (zip_index l 0)
     Prove by induction on l.
  *)
  lemma spec_add_zip_index_corr:
    forall l:list int. spec_add l = add_zip (zip_index l 0)

  let add (l : list int) : int =
    ensures { result = spec_add l }
    add_zip (zip_index l 0)
end
