(* 
def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
*)

module HumanEval060Goal

    use int.Int
    use int.EuclideanDivision

    predicate sum (n : int) (a : int)
    axiom sum_zero :
        forall a. sum 0 a <-> a = 0
    axiom sum_ind :
        forall a n . sum n a <-> exists b. sum (n-1) b /\ a = b + n

    let sum_to_n (n : int) : int =
        ensures { sum n result }
        let ref result = 0 in
        for i = 1 to n do
            result <- result + i
        done;
        result
end

(* INSERT_CHATGPT_CODE *)

module HumanEval060
  use int.Int

  let rec sum_to_n (n: int) : int =
    if n = 1 then 1 else n + sum_to_n (n - 1)
end

module TestHumanEval060

    use int.Int
    use list.List
    use HumanEval060

    let test1 () : bool =
        sum_to_n 30 = 465

    let test1_output () : (int, int, int) =
        (30, sum_to_n 30, 465)

    let test2 () : bool =
        sum_to_n 100 = 5050

    let test2_output () : (int, int, int) =
        (100, sum_to_n 100, 5050)

    let test3 () : bool =
        sum_to_n 5 = 15

    let test3_output () : (int, int, int) =
        (5, sum_to_n 5, 15)

    let test4 () : bool =
        sum_to_n 10 = 55

    let test4_output () : (int, int, int) =
        (10, sum_to_n 10, 55)

    let test5 () : bool =
        sum_to_n 1 = 1

    let test5_output () : (int, int, int) =
        (1, sum_to_n 1, 1)

    let test6 () : bool =
        sum_to_n 0 = 0

    let test6_output () : (int, int, int) =
        (0, sum_to_n 0, 0)

    let test7 () : bool =
        sum_to_n (-10) = 0

    let test7_output () : (int, int, int) =
        ((-10), sum_to_n (-10), 0)

    let test8 () : bool =
        sum_to_n 50 = 1275

    let test8_output () : (int, int, int) =
        (50, sum_to_n 50, 1275)

    let test9 () : bool =
        sum_to_n 200 = 20100

    let test9_output () : (int, int, int) =
        (200, sum_to_n 200, 20100)

    let test10 () : bool =
        sum_to_n 500 = 125250

    let test10_output () : (int, int, int) =
        (500, sum_to_n 500, 125250)

    let testall () : bool = 
        test1() && test2() && test3() && test4() && test5() && test6() && test7() && test8() && test9() && test10()

    let testfail () : list int =
        let ref res = Nil in 
        if not test1() then res <- Cons 1 res;
        if not test2() then res <- Cons 2 res;
        if not test3() then res <- Cons 3 res;
        if not test4() then res <- Cons 4 res;
        if not test5() then res <- Cons 5 res;
        if not test6() then res <- Cons 6 res;
        if not test7() then res <- Cons 7 res;
        if not test8() then res <- Cons 8 res;
        if not test9() then res <- Cons 9 res;
        if not test10() then res <- Cons 10 res;
        res

    let runtest (x : int) : (int, int, int) =
        let ref res = ((-1), (-1), (-1)) in
        if x = 1 then res <- test1_output();
        if x = 2 then res <- test2_output();
        if x = 3 then res <- test3_output();
        if x = 4 then res <- test4_output();
        if x = 5 then res <- test5_output();
        if x = 6 then res <- test6_output();
        if x = 7 then res <- test7_output();
        if x = 8 then res <- test8_output();
        if x = 9 then res <- test9_output();
        if x = 10 then res <- test10_output();
        res
    
    let rec failoutput (l : list int) : list (int, int, int) =
        match l with
        | Nil -> Nil
        | Cons x xs -> Cons (runtest x) (failoutput xs)
        end
    
    let test() : list (int, int, int) =
        let l = testfail () in
        failoutput l

end
