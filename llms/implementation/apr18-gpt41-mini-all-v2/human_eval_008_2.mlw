(* modified
def sum_product(numbers: List[int]) -> list [int]:
    """ For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    [0, 1]
    >>> sum_product([1, 2, 3, 4])
    [10, 24]
    """
*)

module HumanEval008Goal
    use int.Int
    use list.List
    use list.NthNoOpt
    use list.Sum
    use list.Length

    predicate product (l : list int) (q : int)
    axiom product_base: forall l'. length l' = 0 <-> product l' 1
    axiom product_rec : forall x', l', q'. product (Cons x' l') (q'*x') <-> product l' (q')

    let rec helper (l : list int) (sum_acc : int) (product_acc : int) : list int =
        match l with
        | Nil -> Cons (0 + sum_acc) (Cons (1 * product_acc) Nil)
        | Cons x xs -> helper xs (sum_acc + x) (product_acc * x)
        end

    let sum_product (l : list int) : list int =
        ensures { nth 0 result = sum l }
        ensures { product l (nth 1 result) }
        helper l 0 1
end

(* INSERT_CHATGPT_CODE *)

module HumanEval008

  use int.Int
  use list.List

  let rec aux (l : list int) (acc_sum : int) (acc_prod : int) : list int =
    match l with
    | Nil -> Cons acc_sum (Cons acc_prod Nil)
    | Cons x xs -> aux xs (acc_sum + x) (acc_prod * x)
    end

  let sum_product (l : list int) : list int =
    aux l 0 1
end

module TestHumanEval008
 use int.Int
    use list.List
    use list.NthNoOpt
    use list.Length
    use HumanEval008  

    let rec nth_1 (n : int) (l : list int) : int =
        requires { length l > 0 }
        requires { 0 <= n /\ n < length l }
        variant { n }
        ensures { nth n l = result }
        match l with 
        | Cons x r -> if n = 0 then x else nth_1 (n - 1) r
        end 

    let list_eq (l1 : list int) (l2 : list int) : bool =
        requires {length l1 = length l2}
        ensures { result -> forall i. 0 <= i < length l1 -> nth i l1 = nth i l2 }
        let n = length l1 in
        let ref res = true in
        for i = 0 to (n-1) do
            invariant {res = false \/ forall j. 0 <= j < i -> nth j l1 = nth j l2 }
            if not (nth_1 i l1 = nth_1 i l2)
            then res <- false
        done;
        res

    let test1 () : bool =
        list_eq (sum_product (Nil : list int)) (Cons 0 (Cons 1 Nil))

    let test1_output () : (list int, list int, list int) =
        (Nil : list int, sum_product (Nil : list int), Cons 0 (Cons 1 Nil))

    let test2 () : bool =
        list_eq (sum_product (Cons 5 Nil)) (Cons 5 (Cons 5 Nil))

    let test2_output () : (list int, list int, list int) =
        (Cons 5 Nil, sum_product (Cons 5 Nil), Cons 5 (Cons 5 Nil))

    let test3 () : bool =
        list_eq (sum_product (Cons (-3) Nil)) (Cons (-3) (Cons (-3) Nil))

    let test3_output () : (list int, list int, list int) =
        (Cons (-3) Nil, sum_product (Cons (-3) Nil), Cons (-3) (Cons (-3) Nil))

    let test4 () : bool =
        list_eq (sum_product (Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil))))) (Cons 10 (Cons 24 Nil))

    let test4_output () : (list int, list int, list int) =
        (Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil))), sum_product (Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))), Cons 10 (Cons 24 Nil))

    let test5 () : bool =
        list_eq (sum_product (Cons (-1) (Cons 2 (Cons (-3) (Cons 4 Nil))))) (Cons 2 (Cons 24 Nil))

    let test5_output () : (list int, list int, list int) =
        (Cons (-1) (Cons 2 (Cons (-3) (Cons 4 Nil))), sum_product (Cons (-1) (Cons 2 (Cons (-3) (Cons 4 Nil)))), Cons 2 (Cons 24 Nil))

    let test6 () : bool =
        list_eq (sum_product (Cons 0 (Cons 2 (Cons (-3) (Cons 4 Nil))))) (Cons 3 (Cons 0 Nil))

    let test6_output () : (list int, list int, list int) =
        (Cons 0 (Cons 2 (Cons (-3) (Cons 4 Nil))), sum_product (Cons 0 (Cons 2 (Cons (-3) (Cons 4 Nil)))), Cons 3 (Cons 0 Nil))

    let test7 () : bool =
        list_eq (sum_product (Cons 0 (Cons 0 (Cons 0 Nil)))) (Cons 0 (Cons 0 Nil))

    let test7_output () : (list int, list int, list int) =
        (Cons 0 (Cons 0 (Cons 0 Nil)), sum_product (Cons 0 (Cons 0 (Cons 0 Nil))), Cons 0 (Cons 0 Nil))

    let test8 () : bool =
        list_eq (sum_product (Cons (-1) (Cons (-2) (Cons (-3) (Cons (-4) Nil))))) (Cons (-10) (Cons 24 Nil))

    let test8_output () : (list int, list int, list int) =
        (Cons (-1) (Cons (-2) (Cons (-3) (Cons (-4) Nil))), sum_product (Cons (-1) (Cons (-2) (Cons (-3) (Cons (-4) Nil)))), Cons (-10) (Cons 24 Nil))

    let test9 () : bool =
        list_eq (sum_product (Cons 100 (Cons 200 (Cons 300 (Cons 400 Nil))))) (Cons 1000 (Cons 2400000000 Nil))

    let test9_output () : (list int, list int, list int) =
        (Cons 100 (Cons 200 (Cons 300 (Cons 400 Nil))), sum_product (Cons 100 (Cons 200 (Cons 300 (Cons 400 Nil)))), Cons 1000 (Cons 2400000000 Nil))

    let test10 () : bool =
        list_eq (sum_product (Cons 100 (Cons 0 (Cons 300 (Cons 400 Nil))))) (Cons 800 (Cons 0 Nil))

    let test10_output () : (list int, list int, list int) =
        (Cons 100 (Cons 0 (Cons 300 (Cons 400 Nil))), sum_product (Cons 100 (Cons 0 (Cons 300 (Cons 400 Nil)))), Cons 800 (Cons 0 Nil))

    let testall () : bool = 
        test1() && test2() && test3() && test4() && test5() && test6() && test7() && test8() && test9() && test10()

    let testfail () : list int =
        let ref res = Nil in 
        if not test1() then res <- Cons 1 res;
        if not test2() then res <- Cons 2 res;
        if not test3() then res <- Cons 3 res;
        if not test4() then res <- Cons 4 res;
        if not test5() then res <- Cons 5 res;
        if not test6() then res <- Cons 6 res;
        if not test7() then res <- Cons 7 res;
        if not test8() then res <- Cons 8 res;
        if not test9() then res <- Cons 9 res;
        if not test10() then res <- Cons 10 res;
        res

    let runtest (x : int) : (list int, list int, list int) =
        let ref res = (Nil, Nil, Nil) in
        if x = 1 then res <- test1_output();
        if x = 2 then res <- test2_output();
        if x = 3 then res <- test3_output();
        if x = 4 then res <- test4_output();
        if x = 5 then res <- test5_output();
        if x = 6 then res <- test6_output();
        if x = 7 then res <- test7_output();
        if x = 8 then res <- test8_output();
        if x = 9 then res <- test9_output();
        if x = 10 then res <- test10_output();
        res
    
    let rec failoutput (l : list int) : list (list int, list int, list int) =
        match l with
        | Nil -> Nil
        | Cons x xs -> Cons (runtest x) (failoutput xs)
        end
    
    let test() : list (list int, list int, list int) =
        let l = testfail () in
        failoutput l
end