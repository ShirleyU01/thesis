module HumanEval139
  use int.Int
  use int.Fact
  use int.EuclideanDivision

  predicate spec_fact (n : int) (a : int)
    axiom spec_fact_base :
      forall a. spec_fact 1 a <-> a = 1
    axiom spec_fact_ind :
      forall a n. spec_fact n a <-> exists b. spec_fact (n-1) b /\ a = b * fact n

  (* Product of fact(j) for j in [i+1, n] *)
  let rec function fact_range_product (i n: int) : int =
  requires { i <= n }
  variant { n - i }
    if i >= n then 1 else fact (n) * fact_range_product i (n - 1)

  let special_factorial (n: int) : int =
    ensures { spec_fact n result }
    let ref res = 1 in
    let ref i = n in
    while i > 0 do
      invariant { 0 <= i <= n }
      invariant { exists k. k = i /\
        (exists b. spec_fact k b /\ res = b * fact_range_product i n) }
      invariant { forall m:int. i < m <= n -> mod res (fact m) = 0 }
      invariant { exists b. spec_fact i b /\ res = b * fact_range_product i n }
      variant { i }
      res <- res * fact i;
      i <- i - 1
    done;
    res
end
