module HumanEval008
  use int.Int
  use list.List
  use list.Length
  use list.NthNoOpt
  use list.Sum

  predicate product (l : list int) (q : int)
    axiom product_base: forall l'. length l' = 0 <-> product l' 1
    axiom product_rec : forall x', l', q'. product (Cons x' l') (q'*x') <-> product l' (q')

 (* Helper lemma for product function and product_of_list *)
  let rec function product_of_list (l: list int) : int = match l with | Nil -> 1 | Cons x xs -> x * product_of_list xs end


  (* Helper function: computes (sum l + s, product l * p) *)
  let rec fold_sum_prod (l: list int) (s: int) (p: int) : (int, int)
    requires { true }
    ensures  { let (s', p') = result in s' = sum l + s /\ product l p' /\ p' = p * (if length l = 0 then 1 else product_of_list l) }
    variant  { length l }
  =
    match l with
    | Nil -> (s, p)
    | Cons x xs -> fold_sum_prod xs (s + x) (p * x)
    end

  lemma product_nil : product Nil 1
  lemma product_cons : forall x l q. product l q -> product (Cons x l) (q * x)
  lemma product_charac : forall l q. product l q <-> q = product_of_list l

  let sum_product (l: list int) : list int =
    ensures { nth 0 result = sum l }
    ensures { product l (nth 1 result) }
    let (s, p) = fold_sum_prod l 0 1 in
    Cons s (Cons p Nil)
end
