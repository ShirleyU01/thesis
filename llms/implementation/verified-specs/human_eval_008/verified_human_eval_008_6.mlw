module HumanEval008
  use int.Int
  use list.List
  use list.Length
  use list.NthNoOpt
  use list.Sum

  predicate product (l : list int) (q : int)
    axiom product_base: forall l': list int. length l' = 0 <-> product l' 1
    axiom product_rec : forall x': int, l': list int, q': int. product (Cons x' l') (q'*x') <-> product l' (q')

  (* prod computes the product of the list *)
  let rec prod (l: list int) : int
    variant { length l }
    ensures { product l result }
  = match l with
    | Nil -> 1
    | Cons x xs -> x * prod xs
    end

  (* sum is imported from list.Sum: sum l = the sum of l, sum Nil = 0 *)
  (* sum already has the correct semantics for the sum of a list *)

  let sum_product (l: list int) : list int =
    ensures { nth 0 result = sum l }
    ensures { product l (nth 1 result) }
    let s = sum l in
    let p = prod l in
    Cons s (Cons p Nil)

end
