module HumanEval020
  use int.Int
  use int.Abs
  use int.MinMax
  use list.List
  use list.Length
  use list.NthNoOpt
  use list.Append
  use list.Mem
  use list.Permut
  use list.FoldLeft

  (* nth_my: safe version of nth *)
  let rec nth_my (n:int) (l:list int) : int =
    requires { length l > 0 }
    requires { 0 <= n /\ n < length l }
    ensures  { nth n l = result }
    ensures  { mem result l }
    variant { n }
    match l with
    | Cons x r -> if n = 0 then x else nth_my (n-1) r
    end

  (* all_pairs: produces all pairs (d, x, y) with i < j < n *)
  let rec all_pairs (numbers: list int) (i: int) (n: int) : list (int, int, int) =
    requires { 0 <= i /\ i < n /\ n = length numbers }
    ensures  { forall e. mem e result ->
      let (d, x, y) = e in
      exists j. i < j /\ j < n /\ x = nth i numbers /\ y = nth j numbers /\ d = abs (x - y) }
    ensures  { forall k l. (i < k /\ k < n /\ i < l /\ l < n) ->
      mem (abs (nth i numbers - nth l numbers), nth i numbers, nth l numbers) result }
    variant { n - i }
    if i >= n-1 then Nil
    else
      let rec aux (j: int) : list (int, int, int) =
        requires { i+1 <= j /\ j <= n }
        ensures  { forall e. mem e result ->
          let (d, x, y) = e in
          exists k. j <= k < n /\ x = nth i numbers /\ y = nth k numbers /\ d = abs (x - y) }
        ensures  { length result = n - j }
        variant { n - j }
        if j >= n then Nil
        else
          let x = nth_my i numbers in
          let y = nth_my j numbers in
          let d = abs (x - y) in
          Cons (d, x, y) (aux (j+1))
      in
      aux (i+1) ++ all_pairs numbers (i+1) n

  (* min_pair: returns (a, b) where min_d is the minimum d seen so far *)
  let rec min_pair (l: list (int, int, int)) (min_d:int) (a:int) (b:int) : (int, int) =
    requires { forall e. mem e l -> let (d, x, y) = e in d >= 0 }
    ensures  { let (ra, rb) = result in
      (* min_d is the minimum d in l or initial min_d *)
      let m = fold_left (fun acc e -> let (d, x, y) = e in if d < acc then d else acc) min_d l in
      exists e. (mem e l \/ (l = Nil /\ min_d = abs (a - b))) /\ let (d, x, y) = e in d = m /\ ra = min x y /\ rb = max x y }
    variant { length l }
    match l with
    | Nil -> (a, b)
    | Cons (d, x, y) xs ->
      if d < min_d then min_pair xs d (min x y) (max x y)
      else min_pair xs min_d a b
    end

  (* Main function *)
  let find_closest_elements (numbers: list int) : list int =
    requires { length numbers >= 2 }
    ensures  { length result = 2 }
    ensures  { let a = nth 0 result in let b = nth 1 result in a <= b }
    ensures  { mem (nth 0 result) numbers /\ mem (nth 1 result) numbers }
    ensures  { let a = nth 0 result in let b = nth 1 result in
      forall i. 0 <= i < length numbers ->
      forall j. 0 <= j < length numbers -> i <> j -> abs (a - b) <= abs (nth i numbers - nth j numbers) }
    let n = length numbers in
    let x0 = nth_my 0 numbers in
    let x1 = nth_my 1 numbers in
    let pairs = all_pairs numbers 0 n in
    let (a, b) = min_pair pairs (abs (x0 - x1)) (min x0 x1) (max x0 x1) in
    Cons a (Cons b Nil)
end
