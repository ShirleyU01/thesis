module HumanEval085
  use int.Int
  use int.EuclideanDivision
  use list.List
  use list.Length
  use list.NthNoOpt

  function spec_add (l : list int) : int =
    match l with
    | Cons _ (Cons y ys) ->
        (if mod y 2 = 0 then y else 0) + spec_add ys
    | _ -> 0
    end

  predicate even (x:int) = mod x 2 = 0
  predicate odd (x:int) = mod x 2 = 1

    (* Pure ghost function version of zip_index for use in contracts *)
  function zip_index_fun (l : list int) (i : int) : list (int, int) =
    match l with
    | Nil -> Nil
    | Cons x xs -> Cons (i, x) (zip_index_fun xs (i + 1))
    end

  (* Replace the ensures clause to use zip_index_fun *)
  let rec zip_index (l : list int) (i : int) : list (int, int)
    variant { length l }
    ensures { forall j:int, x:int. 0 <= j < length l ->
      nth j result = (i + j, nth j l)
    }
    ensures { result = zip_index_fun l i }
  =
    match l with
    | Nil -> Nil
    | Cons x xs -> Cons (i, x) (zip_index xs (i + 1))
    end


  (* Logic function for the specification of add_zip *)
  function sum_zip_fun (l: list (int, int)) : int =
    match l with
    | Nil -> 0
    | Cons (i, x) xs -> (if odd i && even x then x else 0) + sum_zip_fun xs
    end

  (* add_zip adds up x where index is odd and x is even *)
  let rec add_zip (l : list (int, int)) : int
    variant { length l }
    ensures { result = sum_zip_fun l }
  =
    match l with
    | Nil -> 0
    | Cons (i, x) xs ->
        let s = add_zip xs in
        if mod i 2 = 1 && mod x 2 = 0 then x + s else s
    end


  (*
     Lemma: For all l, spec_add l = add_zip (zip_index l 0)
     Prove by induction on l.
  *)
lemma spec_add_zip_index_corr:
  forall l: list int. spec_add l = sum_zip_fun (zip_index_fun l 0)


  let add (l : list int) : int =
    ensures { result = spec_add l }
    add_zip (zip_index l 0)
end
