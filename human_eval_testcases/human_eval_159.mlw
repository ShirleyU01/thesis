(*
def eat(number, need, remaining):
    """
    You're a hungry rabbit, and you already have eaten a certain number of carrots,
    but now you need to eat more carrots to complete the day's meals.
    you should return an array of [ total number of eaten carrots after your meals,
                                    the number of carrots left after your meals ]
    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.

    Example:
    * eat(5, 6, 10) -> [11, 4]
    * eat(4, 8, 9) -> [12, 1]
    * eat(1, 10, 10) -> [11, 0]
    * eat(2, 11, 5) -> [7, 0]

    Variables:
    @number : integer
        the number of carrots that you have eaten.
    @need : integer
        the number of carrots that you need to eat.
    @remaining : integer
        the number of remaining carrots thet exist in stock

    Constrain:
    * 0 <= number <= 1000
    * 0 <= need <= 1000
    * 0 <= remaining <= 1000

    Have fun :)
    """

 *)

module HumanEval159

    use int.Int
    use list.List

    let eat (number : int) (need : int) (remaining : int) : list int =
        if need <= remaining 
        then Cons (need + number) (Cons (remaining - need) Nil)
        else Cons (number + remaining) (Cons 0 Nil)

end

module TestHumanEval159

    use int.Int
    use list.List
    use list.NthNoOpt
    use list.Length
    use HumanEval159

    let rec nth_1 (n : int) (l : list int) : int =
        requires { length l > 0 }
        requires { 0 <= n /\ n < length l }
        variant { n }
        ensures { nth n l = result }
        match l with 
        | Cons x r -> if n = 0 then x else nth_1 (n - 1) r
        end 

    let list_eq (l1 : list int) (l2 : list int) : bool =
        requires {length l1 = length l2}
        ensures { result -> forall i. 0 <= i < length l1 -> nth i l1 = nth i l2 }
        let n = length l1 in
        let ref res = true in
        for i = 0 to (n-1) do
            invariant {res = false \/ forall j. 0 <= j < i -> nth j l1 = nth j l2 }
            if not (nth_1 i l1 = nth_1 i l2)
            then res <- false
        done;
        res


    let test1 () : bool =
        list_eq (eat 5 6 10) (Cons 11 (Cons 4 Nil))

    let test2 () : bool =
        list_eq (eat 4 8 9) (Cons 12 (Cons 1 Nil))

    let test3 () : bool =
        list_eq (eat 1 10 10) (Cons 11 (Cons 0 Nil))

    let test4 () : bool =
        list_eq (eat 2 11 5) (Cons 7 (Cons 0 Nil))

    let test5 () : bool =
        list_eq (eat 0 5 5) (Cons 5 (Cons 0 Nil))

    let test6 () : bool =
        list_eq (eat 100 200 150) (Cons 250 (Cons 0 Nil))

    let test7 () : bool =
        list_eq (eat 500 500 0) (Cons 500 (Cons 0 Nil))

    let test8 () : bool =
        list_eq (eat 0 0 1000) (Cons 0 (Cons 1000 Nil))

    let test9 () : bool =
        list_eq (eat 1000 1000 1000) (Cons 2000 (Cons 0 Nil))

    let test10 () : bool =
        list_eq (eat 10 1 0) (Cons 10 (Cons 0 Nil))

    let testall () : bool = 
        test1() && test2() && test3() && test4() && test5() && test6() && test7() && test8() && test9() && test10()

end
